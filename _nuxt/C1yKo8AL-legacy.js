System.register(["./DSdbEaNu-legacy.js"],(function(e,t){"use strict";var n,r,s,i,a,o,u,c,p,d,l,y,m,f,h,g,b,v,w,$,x,I,A,j;return{setters:[e=>{n=e.aT,r=e.c7,s=e.c8,i=e.c9,a=e.ca,o=e.cb,u=e.cc,c=e.br,p=e.cd,d=e.bW,l=e.b$,y=e.ce,m=e.bx,f=e.bz,h=e.cf,g=e.cg,b=e.bE,v=e.c3,w=e.bD,$=e.ch,x=e.ci,I=e.bB,A=e.bR,j=e.bK}],execute:function(){e({k:Me,l:function(e){try{const t=Be(e);return p(Ae({type:"tuple",name:"",components:t},e).encoded)}catch(n){throw new t("Could not infer types from given params",{params:e})}}}),e("F",class extends n{constructor(){super(...arguments),this.code=s}}),e("M",class extends n{constructor(){super("The method you're trying to call is not implemented."),this.code=u}}),e("O",class extends n{constructor(){super(...arguments),this.code=a}}),e("g",class extends n{constructor(){super(...arguments),this.code=o}});class t extends n{constructor(e,t){super(e),this.code=r,this.props=null!=t?t:{}}}e("A",t),e("E",class extends n{constructor(e){super(`A plugin with the namespace: ${e} has already been registered.`),this.code=i}}),e("n",(e=>"object"==typeof e&&!c(e)&&0!==Object.keys(e).length&&["input","data","from","gas","gasPrice","gasLimit","address","jsonInterface","syncWithContext","dataInputFill"].some((t=>t in e))));const B=e("i",c),M=e("a",(e=>!B(e)&&"object"==typeof e&&!B(e.type)&&"error"===e.type)),k=e("b",(e=>!B(e)&&"object"==typeof e&&!B(e.type)&&"event"===e.type)),O=e("o",(e=>!B(e)&&"object"==typeof e&&!B(e.type)&&"function"===e.type)),N=(e("m",(e=>!B(e)&&"object"==typeof e&&!B(e.type)&&"constructor"===e.type)),e=>"object"==typeof e&&void 0===e.components&&void 0===e.name),S=e=>e.includes("[]")?{type:"tuple[]",name:e.slice(0,-2)}:{type:"tuple",name:e},z=e=>{const t=[];for(const n of Object.keys(e)){const r=e[n];"object"==typeof r?t.push(Object.assign(Object.assign({},S(n)),{components:z(r)})):t.push({name:n,type:e[n]})}return t},_=(e,n)=>{const r=[];return n.forEach((n=>{if("object"==typeof n.components){if(!n.type.startsWith("tuple"))throw new t(`Invalid value given "${n.type}". Error: components found but type is not tuple.`);const s=n.type.indexOf("["),i=s>=0?n.type.substring(s):"",a=_(e,n.components);Array.isArray(a)&&e?r.push(`tuple(${a.join(",")})${i}`):r.push(`(${a.join(",")})${i}`)}else r.push(n.type)})),r},W=e("j",(e=>{var t,n,r,s;return M(e)||k(e)||O(e)?(null===(t=e.name)||void 0===t?void 0:t.includes("("))?e.name:`${null!==(n=e.name)&&void 0!==n?n:""}(${_(!1,null!==(r=e.inputs)&&void 0!==r?r:[]).join(",")})`:`(${_(!1,null!==(s=e.inputs)&&void 0!==s?s:[]).join(",")})`}));function P(e,t){const n=e.exec(t);return n?.groups}var E=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,U=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,T=/^\(.+?\).*?$/,L=Object.defineProperty,D=(e,t,n)=>(((e,t,n)=>{t in e?L(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n),R=class extends Error{constructor(e,t={}){const n=t.cause instanceof R?t.cause.details:t.cause?.message?t.cause.message:t.details,r=t.cause instanceof R&&t.cause.docsPath||t.docsPath;super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...r?[`Docs: https://abitype.dev${r}`]:[],...n?[`Details: ${n}`]:[],"Version: abitype@0.7.1"].join("\n")),D(this,"details"),D(this,"docsPath"),D(this,"metaMessages"),D(this,"shortMessage"),D(this,"name","AbiTypeError"),t.cause&&(this.cause=t.cause),this.details=n,this.docsPath=r,this.metaMessages=t.metaMessages,this.shortMessage=e}},Z=/^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;function C(e){return Z.test(e)}function F(e){return P(Z,e)}var q=new Set(["memory","indexed","storage","calldata"]),G=new Set(["calldata","memory","storage"]),J=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]),K=/^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,V=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,X=/^u?int$/;function Y(e,t){const n=function(e,t){return t?`${t}:${e}`:e}(e,t?.type);if(J.has(n))return J.get(n);const r=T.test(e),s=P(r?V:K,e);if(!s)throw new R("Invalid ABI parameter.",{details:e});if(s.name&&function(e){return"address"===e||"bool"===e||"function"===e||"string"===e||"tuple"===e||E.test(e)||U.test(e)||ee.test(e)}(s.name))throw new R("Invalid ABI parameter.",{details:e,metaMessages:[`"${s.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]});const i=s.name?{name:s.name}:{},a="indexed"===s.modifier?{indexed:!0}:{},o=t?.structs??{};let u,c={};if(r){u="tuple";const e=H(s.type),t=[],n=e.length;for(let r=0;r<n;r++)t.push(Y(e[r],{structs:o}));c={components:t}}else if(s.type in o)u="tuple",c={components:o[s.type]};else if(X.test(s.type))u=`${s.type}256`;else if(u=s.type,"struct"!==t?.type&&!Q(u))throw new R("Unknown type.",{metaMessages:[`Type "${u}" is not a valid ABI type.`]});if(s.modifier){if(!t?.modifiers?.has?.(s.modifier))throw new R("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${s.modifier}" not allowed${t?.type?` in "${t.type}" type`:""}.`]});if(G.has(s.modifier)&&!function(e,t){return t||"bytes"===e||"string"===e||"tuple"===e}(u,!!s.array))throw new R("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${s.modifier}" not allowed${t?.type?` in "${t.type}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${s.modifier}" was given.`]})}const p={type:`${u}${s.array??""}`,...i,...a,...c};return J.set(n,p),p}function H(e,t=[],n="",r=0){if(""===e){if(""===n)return t;if(0!==r)throw new R("Unbalanced parentheses.",{metaMessages:[`"${n.trim()}" has too many ${r>0?"opening":"closing"} parentheses.`],details:`Depth "${r}"`});return[...t,n.trim()]}const s=e.length;for(let i=0;i<s;i++){const s=e[i],a=e.slice(i+1);switch(s){case",":return 0===r?H(a,[...t,n.trim()]):H(a,t,`${n}${s}`,r);case"(":return H(a,t,`${n}${s}`,r+1);case")":return H(a,t,`${n}${s}`,r-1);default:return H(a,t,`${n}${s}`,r)}}return[]}function Q(e){return"address"===e||"bool"===e||"function"===e||"string"===e||E.test(e)||U.test(e)}var ee=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/,te=/^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;function ne(e,t,n=new Set){const r=[],s=e.length;for(let i=0;i<s;i++){const s=e[i];if(T.test(s.type))r.push(s);else{const e=P(te,s.type);if(!e?.type)throw new R("Invalid ABI parameter.",{details:JSON.stringify(s,null,2),metaMessages:["ABI parameter type is invalid."]});const{array:i,type:a}=e;if(a in t){if(n.has(a))throw new R("Circular reference detected.",{metaMessages:[`Struct "${a}" is a circular reference.`]});r.push({...s,type:`tuple${i??""}`,components:ne(t[a]??[],t,new Set([...n,a]))})}else{if(!Q(a))throw new R("Unknown type.",{metaMessages:[`Type "${a}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]});r.push(s)}}}return r}function re(e){let t;if("string"==typeof e)t=Y(e,{modifiers:q});else{const n=function(e){const t={},n=e.length;for(let a=0;a<n;a++){const n=e[a];if(!C(n))continue;const r=F(n);if(!r)throw new R("Invalid struct signature.",{details:n});const s=r.properties.split(";"),i=[],o=s.length;for(let e=0;e<o;e++){const t=s[e].trim();if(!t)continue;const n=Y(t,{type:"struct"});i.push(n)}if(!i.length)throw new R("Invalid struct signature.",{details:n,metaMessages:["No properties exist."]});t[r.name]=i}const r={},s=Object.entries(t),i=s.length;for(let a=0;a<i;a++){const[e,n]=s[a];r[e]=ne(n,t)}return r}(e),r=e.length;for(let s=0;s<r;s++){const r=e[s];if(!C(r)){t=Y(r,{modifiers:q,structs:n});break}}}if(!t)throw new R("Failed to parse ABI parameter.",{details:`parseAbiParameter(${JSON.stringify(e,null,2)})`,docsPath:"/api/human.html#parseabiparameter-1"});return t}const se=32;function ie(e=0){var t;if(void 0!==(null===(t=globalThis.Buffer)||void 0===t?void 0:t.alloc)){const t=globalThis.Buffer.alloc(e);return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}return new Uint8Array(e)}function ae(e){var t,n;return Object.assign(Object.assign({},e),{name:null!==(t=e.name)&&void 0!==t?t:"",components:null===(n=e.components)||void 0===n?void 0:n.map((e=>ae(e)))})}function oe(e){return e.map((e=>{var n,r;if(!B(r=e)&&"object"==typeof r&&!B(r.type)&&"string"==typeof r.type)return e;if("string"==typeof e)return ae(re(e.replace(/tuple/,"")));if(N(e)){const t=Object.keys(e)[0],r=S(t);return r.name=null!==(n=r.name)&&void 0!==n?n:"",Object.assign(Object.assign({},r),{components:z(e[t])})}throw new t("Invalid abi")}))}function ue(e){const n=e.type.lastIndexOf("["),r=e.type.substring(0,n),s=e.type.substring(n);let i=-1;if("[]"!==s&&(i=Number(s.slice(1,-1)),isNaN(i)))throw new t("Invalid fixed array size",{size:s});return{param:{type:r,name:"",components:e.components},size:i}}function ce(e){var t,n;return!("string"!==e.type&&"bytes"!==e.type&&!e.type.endsWith("[]"))||("tuple"===e.type?null!==(n=null===(t=e.components)||void 0===t?void 0:t.some(ce))&&void 0!==n&&n:!!e.type.endsWith("]")&&ce(ue(e).param))}const pe=20,de=se-pe,le=new Map;let ye=BigInt(256);for(let e=8;e<=256;e+=8)le.set(`uint${e}`,{min:BigInt(0),max:ye-BigInt(1)}),le.set(`int${e}`,{min:-ye/BigInt(2),max:ye/BigInt(2)-BigInt(1)}),ye*=BigInt(256);le.set("int",le.get("int256")),le.set("uint",le.get("uint256"));const me=BigInt(1)<<BigInt(256);function fe(e,t=se){let n;return n=e<0?(me+e).toString(16):e.toString(16),n=f(n,2*t),y(n)}function he(e,n){let r;try{r=m(n)}catch(i){throw new t("provided input is not number value",{type:e.type,value:n,name:e.name})}const s=le.get(e.type);if(!s)throw new t("provided abi contains invalid number datatype",{type:e.type});if(r<s.min)throw new t("provided input is less then minimum for given type",{type:e.type,value:n,name:e.name,minimum:s.min.toString()});if(r>s.max)throw new t("provided input is greater then maximum for given type",{type:e.type,value:n,name:e.name,maximum:s.max.toString()});return{dynamic:!1,encoded:fe(r)}}function ge(e,n){if(n.length<se)throw new t("Not enough bytes left to decode",{param:e,bytesLeft:n.length});const r=n.subarray(0,se),s=le.get(e.type);if(!s)throw new t("provided abi contains invalid number datatype",{type:e.type});const i=function(e,t){const n=p(e),r=BigInt(n);return r<=t?r:r-me}(r,s.max);if(i<s.min)throw new t("decoded value is less then minimum for given type",{type:e.type,value:i,name:e.name,minimum:s.min.toString()});if(i>s.max)throw new t("decoded value is greater then maximum for given type",{type:e.type,value:i,name:e.name,maximum:s.max.toString()});return{result:i,encoded:n.subarray(se),consumed:se}}const be=32;function ve(e,n){if("string"==typeof n&&n.length%2!=0&&(n+="0"),!v(n))throw new t("provided input is not valid bytes value",{type:e.type,value:n,name:e.name});const r=w(n),[,s]=e.type.split("bytes");if(s){if(Number(s)>be||Number(s)<1)throw new t("invalid bytes type. Static byte type can have between 1 and 32 bytes",{type:e.type});if(Number(s)<r.length)throw new t("provided input size is different than type size",{type:e.type,value:n,name:e.name});const i=ie(se);return i.set(r),{dynamic:!1,encoded:i}}const i=Math.ceil(r.length/se),a=ie(se+i*se);return a.set(he({type:"uint32",name:""},r.length).encoded),a.set(r,se),{dynamic:!0,encoded:a}}function we(e,n){const[,r]=e.type.split("bytes");let s=Number(r),i=n,a=1,o=0;if(!s){const e=ge({type:"uint32",name:""},i);s=Number(e.result),o+=e.consumed,i=e.encoded,a=Math.ceil(s/se)}if(s>n.length)throw new t("there is not enough data to decode",{type:e.type,encoded:n,size:s});return{result:b(i.subarray(0,s)),encoded:i.subarray(a*se),consumed:o+a*se}}function $e(e){let t=0,n=0;const r=[],s=[];for(const i of e)i.dynamic?t+=se:t+=i.encoded.length;for(const i of e)i.dynamic?(r.push(he({type:"uint256",name:""},t+n)),s.push(i),n+=i.encoded.length):r.push(i);return I(...r.map((e=>e.encoded)),...s.map((e=>e.encoded)))}function xe(e,n){if("string"===e.type)return function(e,n){if("string"!=typeof n)throw new t("invalid input, should be string",{input:n});return ve({type:"bytes",name:""},x(n))}(0,n);if("bool"===e.type)return function(e,n){let r;try{r=h(n)}catch(s){if(s instanceof g)throw new t("provided input is not valid boolean value",{type:e.type,value:n,name:e.name})}return he({type:"uint8",name:""},Number(r))}(e,n);if("address"===e.type)return function(e,n){if("string"!=typeof n)throw new t("address type expects string as input type",{value:n,name:e.name,type:e.type});let r=n.toLowerCase();if(r.startsWith("0x")||(r=`0x${r}`),!l(r))throw new t("provided input is not valid address",{value:n,name:e.name,type:e.type});const s=y(r),i=ie(se);return i.set(s,de),{dynamic:!1,encoded:i}}(e,n);if("tuple"===e.type)return Ae(e,n);if(e.type.endsWith("]"))return function(e,n){if(!Array.isArray(n))throw new t("Expected value to be array",{abi:e,values:n});const{size:r,param:s}=ue(e),i=n.map((e=>xe(s,e))),a=-1===r,o=i.length>0&&i[0].dynamic;if(!a&&n.length!==r)throw new t("Given arguments count doesn't match array length",{arrayLength:r,argumentsLength:n.length});if(a||o){const e=$e(i);if(a){const t=he({type:"uint256",name:""},i.length).encoded;return{dynamic:!0,encoded:i.length>0?I(t,e):t}}return{dynamic:!0,encoded:e}}return{dynamic:!1,encoded:I(...i.map((e=>e.encoded)))}}(e,n);if(e.type.startsWith("bytes"))return ve(e,n);if(e.type.startsWith("uint")||e.type.startsWith("int"))return he(e,n);throw new t("Unsupported",{param:e,value:n})}function Ie(e,n){if("string"===e.type)return function(e,t){const n=we({type:"bytes",name:""},t);return{result:$(n.result),encoded:n.encoded,consumed:n.consumed}}(0,n);if("bool"===e.type)return function(e,n){const r=ge({type:"uint8",name:""},n);if(r.result>1||r.result<0)throw new t("Invalid boolean value encoded",{boolBytes:n.subarray(0,se),numberResult:r});return{result:r.result===BigInt(1),encoded:r.encoded,consumed:se}}(0,n);if("address"===e.type)return function(e,n){const r=n.subarray(de,se);if(r.length!==pe)throw new t("Invalid decoding input, not enough bytes to decode address",{bytes:n});const s=p(r);return{result:d(s),encoded:n.subarray(se),consumed:se}}(0,n);if("tuple"===e.type)return je(e,n);if(e.type.endsWith("]"))return function(e,t){let{size:n,param:r}=ue(e),s=0;const i=[];let a=t;if(-1===n){const e=ge({type:"uint32",name:""},t);n=Number(e.result),s=e.consumed,a=e.encoded}if(ce(r)){for(let e=0;e<n;e+=1){const t=ge({type:"uint32",name:""},a.subarray(e*se));s+=t.consumed;const n=Ie(r,a.subarray(Number(t.result)));s+=n.consumed,i.push(n.result)}return{result:i,encoded:a.subarray(s),consumed:s}}for(let o=0;o<n;o+=1){const e=Ie(r,t.subarray(s));s+=e.consumed,i.push(e.result)}return{result:i,encoded:t.subarray(s),consumed:s}}(e,n);if(e.type.startsWith("bytes"))return we(e,n);if(e.type.startsWith("uint")||e.type.startsWith("int"))return ge(e,n);throw new t("Unsupported",{param:e,bytes:n})}function Ae(e,n){var r,s,i;let a=!1;if(!Array.isArray(n)&&"object"!=typeof n)throw new t("param must be either Array or Object",{param:e,input:n});const o=n,u=[];for(let c=0;c<(null!==(s=null===(r=e.components)||void 0===r?void 0:r.length)&&void 0!==s?s:0);c+=1){const r=e.components[c];let s;if(Array.isArray(o)){if(c>=o.length)throw new t("input param length missmatch",{param:e,input:n});s=xe(r,o[c])}else{const a=o[null!==(i=r.name)&&void 0!==i?i:""];if(null==a)throw new t("missing input defined in abi",{param:e,input:n,paramName:r.name});s=xe(r,a)}s.dynamic&&(a=!0),u.push(s)}return a?{dynamic:!0,encoded:$e(u)}:{dynamic:!1,encoded:I(...u.map((e=>e.encoded)))}}function je(e,t){const n={__length__:0};let r=0;if(!e.components)return{result:n,encoded:t,consumed:r};let s=0;for(const[i,a]of e.components.entries()){let e;if(ce(a)){const n=ge({type:"uint32",name:""},t.subarray(r));e=Ie(a,t.subarray(Number(n.result))),r+=n.consumed,s+=e.consumed}else e=Ie(a,t.subarray(r)),r+=e.consumed;n.__length__+=1,n[i]=e.result,a.name&&""!==a.name&&(n[a.name]=e.result)}return{encoded:t.subarray(r+s),result:n,consumed:r+s}}function Be(e){const t=[];return e.forEach((e=>{if(Array.isArray(e)){const n=Be(e);t.push({type:"tuple",components:n,name:""})}else t.push({type:A(e,!0)})})),t}function Me(e,n){if((null==e?void 0:e.length)!==n.length)throw new t("Invalid number of values received for given ABI",{expected:null==e?void 0:e.length,received:n.length});const r=oe(e);return p(Ae({type:"tuple",name:"",components:r},n).encoded)}e("h",((e,t)=>Me([e],[t])));const ke=e("c",((e,n,r)=>{try{if(e.length>0&&(!n||"0x"===n||"0X"===n))throw new t("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");return function(e,t){return je({type:"tuple",name:"",components:oe(e)},y(t)).result}(e,`0x${n.replace(/0x/i,"")}`)}catch(s){throw new t(`Parameter decoding error: ${s.message}`,{internalErr:s})}})),Oe=e("d",((e,t)=>ke(e,t,!1)));e("f",((e,t)=>Oe([e],t)[0])),e("e",(e=>{if("string"!=typeof e&&!O(e))throw new t("Invalid parameter value in encodeFunctionSignature");let n;return n=!e||"function"!=typeof e&&"object"!=typeof e?e:W(e),j(n).slice(0,10)}))}}}));
