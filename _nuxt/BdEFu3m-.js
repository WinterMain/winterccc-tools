import{aT as w,c7 as le,c8 as ye,c9 as fe,ca as me,cb as pe,cc as he,br as L,cd as E,bW as ge,b$ as be,ce as k,bx as ve,bz as we,cf as Ae,cg as xe,bE as Ie,c3 as _e,bD as $e,ch as Pe,ci as Se,bB as P,bR as Te,bK as Be}from"./CqK3pOxO.js";class ft extends w{constructor(){super(...arguments),this.code=ye}}class mt extends w{constructor(){super("The method you're trying to call is not implemented."),this.code=he}}class pt extends w{constructor(){super(...arguments),this.code=me}}class ht extends w{constructor(){super(...arguments),this.code=pe}}class c extends w{constructor(t,n){super(t),this.code=le,this.props=n!=null?n:{}}}class gt extends w{constructor(t){super("A plugin with the namespace: ".concat(t," has already been registered.")),this.code=fe}}const bt=e=>typeof e=="object"&&!L(e)&&Object.keys(e).length!==0&&["input","data","from","gas","gasPrice","gasLimit","address","jsonInterface","syncWithContext","dataInputFill"].some(t=>t in e),p=L,Ee=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="error",Re=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="event",Z=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="function",vt=e=>!p(e)&&typeof e=="object"&&!p(e.type)&&e.type==="constructor",Oe=e=>typeof e=="object"&&typeof e.components>"u"&&typeof e.name>"u",G=e=>e.includes("[]")?{type:"tuple[]",name:e.slice(0,-2)}:{type:"tuple",name:e},K=e=>{const t=[];for(const n of Object.keys(e)){const r=e[n];typeof r=="object"?t.push(Object.assign(Object.assign({},G(n)),{components:K(r)})):t.push({name:n,type:e[n]})}return t},N=(e,t)=>{const n=[];return t.forEach(r=>{if(typeof r.components=="object"){if(!r.type.startsWith("tuple"))throw new c('Invalid value given "'.concat(r.type,'". Error: components found but type is not tuple.'));const s=r.type.indexOf("["),i=s>=0?r.type.substring(s):"",a=N(e,r.components);Array.isArray(a)&&e?n.push("tuple(".concat(a.join(","),")").concat(i)):n.push("(".concat(a.join(","),")").concat(i))}else n.push(r.type)}),n},Me=e=>{var t,n,r,s;return Ee(e)||Re(e)||Z(e)?!((t=e.name)===null||t===void 0)&&t.includes("(")?e.name:"".concat((n=e.name)!==null&&n!==void 0?n:"","(").concat(N(!1,(r=e.inputs)!==null&&r!==void 0?r:[]).join(","),")"):"(".concat(N(!1,(s=e.inputs)!==null&&s!==void 0?s:[]).join(","),")")};function W(e,t){const n=e.exec(t);return n==null?void 0:n.groups}var H=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,V=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,X=/^\(.+?\).*?$/,Ne=Object.defineProperty,Ce=(e,t,n)=>t in e?Ne(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,x=(e,t,n)=>(Ce(e,typeof t!="symbol"?t+"":t,n),n),je="abitype",ke="0.7.1",m=class extends Error{constructor(e,t={}){var i;const n=t.cause instanceof m?t.cause.details:(i=t.cause)!=null&&i.message?t.cause.message:t.details,r=t.cause instanceof m&&t.cause.docsPath||t.docsPath,s=[e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...r?["Docs: https://abitype.dev".concat(r)]:[],...n?["Details: ".concat(n)]:[],"Version: ".concat(je,"@").concat(ke)].join("\n");super(s),x(this,"details"),x(this,"docsPath"),x(this,"metaMessages"),x(this,"shortMessage"),x(this,"name","AbiTypeError"),t.cause&&(this.cause=t.cause),this.details=n,this.docsPath=r,this.metaMessages=t.metaMessages,this.shortMessage=e}},Y=new RegExp("^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$");function q(e){return Y.test(e)}function We(e){return W(Y,e)}var U=new Set(["memory","indexed","storage","calldata"]),ze=new Set(["calldata","memory","storage"]);function Fe(e,t){return t?"".concat(t,":").concat(e):e}var M=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]),De=new RegExp("^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$"),Ue=new RegExp("^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$"),Le=/^u?int$/;function S(e,t){var f,h,R,A;const n=Fe(e,t==null?void 0:t.type);if(M.has(n))return M.get(n);const r=X.test(e),s=W(r?Ue:De,e);if(!s)throw new m("Invalid ABI parameter.",{details:e});if(s.name&&Ge(s.name))throw new m("Invalid ABI parameter.",{details:e,metaMessages:['"'.concat(s.name,'" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html')]});const i=s.name?{name:s.name}:{},a=s.modifier==="indexed"?{indexed:!0}:{},o=(f=t==null?void 0:t.structs)!=null?f:{};let d,u={};if(r){d="tuple";const _=b(s.type),D=[],ue=_.length;for(let O=0;O<ue;O++)D.push(S(_[O],{structs:o}));u={components:D}}else if(s.type in o)d="tuple",u={components:o[s.type]};else if(Le.test(s.type))d="".concat(s.type,"256");else if(d=s.type,(t==null?void 0:t.type)!=="struct"&&!J(d))throw new m("Unknown type.",{metaMessages:['Type "'.concat(d,'" is not a valid ABI type.')]});if(s.modifier){if(!((R=(h=t==null?void 0:t.modifiers)==null?void 0:h.has)!=null&&R.call(h,s.modifier)))throw new m("Invalid ABI parameter.",{details:e,metaMessages:['Modifier "'.concat(s.modifier,'" not allowed').concat(t!=null&&t.type?' in "'.concat(t.type,'" type'):"",".")]});if(ze.has(s.modifier)&&!Ke(d,!!s.array))throw new m("Invalid ABI parameter.",{details:e,metaMessages:['Modifier "'.concat(s.modifier,'" not allowed').concat(t!=null&&t.type?' in "'.concat(t.type,'" type'):"","."),'Data location can only be specified for array, struct, or mapping types, but "'.concat(s.modifier,'" was given.')]})}const y={type:"".concat(d).concat((A=s.array)!=null?A:""),...i,...a,...u};return M.set(n,y),y}function b(e,t=[],n="",r=0){if(e===""){if(n==="")return t;if(r!==0)throw new m("Unbalanced parentheses.",{metaMessages:['"'.concat(n.trim(),'" has too many ').concat(r>0?"opening":"closing"," parentheses.")],details:'Depth "'.concat(r,'"')});return[...t,n.trim()]}const s=e.length;for(let i=0;i<s;i++){const a=e[i],o=e.slice(i+1);switch(a){case",":return r===0?b(o,[...t,n.trim()]):b(o,t,"".concat(n).concat(a),r);case"(":return b(o,t,"".concat(n).concat(a),r+1);case")":return b(o,t,"".concat(n).concat(a),r-1);default:return b(o,t,"".concat(n).concat(a),r)}}return[]}function J(e){return e==="address"||e==="bool"||e==="function"||e==="string"||H.test(e)||V.test(e)}var Ze=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;function Ge(e){return e==="address"||e==="bool"||e==="function"||e==="string"||e==="tuple"||H.test(e)||V.test(e)||Ze.test(e)}function Ke(e,t){return t||e==="bytes"||e==="string"||e==="tuple"}function He(e){const t={},n=e.length;for(let a=0;a<n;a++){const o=e[a];if(!q(o))continue;const d=We(o);if(!d)throw new m("Invalid struct signature.",{details:o});const u=d.properties.split(";"),y=[],f=u.length;for(let h=0;h<f;h++){const A=u[h].trim();if(!A)continue;const _=S(A,{type:"struct"});y.push(_)}if(!y.length)throw new m("Invalid struct signature.",{details:o,metaMessages:["No properties exist."]});t[d.name]=y}const r={},s=Object.entries(t),i=s.length;for(let a=0;a<i;a++){const[o,d]=s[a];r[o]=Q(d,t)}return r}var Ve=new RegExp("^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$");function Q(e,t,n=new Set){var i;const r=[],s=e.length;for(let a=0;a<s;a++){const o=e[a];if(X.test(o.type))r.push(o);else{const u=W(Ve,o.type);if(!(u!=null&&u.type))throw new m("Invalid ABI parameter.",{details:JSON.stringify(o,null,2),metaMessages:["ABI parameter type is invalid."]});const{array:y,type:f}=u;if(f in t){if(n.has(f))throw new m("Circular reference detected.",{metaMessages:['Struct "'.concat(f,'" is a circular reference.')]});r.push({...o,type:"tuple".concat(y!=null?y:""),components:Q((i=t[f])!=null?i:[],t,new Set([...n,f]))})}else if(J(f))r.push(o);else throw new m("Unknown type.",{metaMessages:['Type "'.concat(f,'" is not a valid ABI type. Perhaps you forgot to include a struct signature?')]})}}return r}function Xe(e){let t;if(typeof e=="string")t=S(e,{modifiers:U});else{const n=He(e),r=e.length;for(let s=0;s<r;s++){const i=e[s];if(!q(i)){t=S(i,{modifiers:U,structs:n});break}}}if(!t)throw new m("Failed to parse ABI parameter.",{details:"parseAbiParameter(".concat(JSON.stringify(e,null,2),")"),docsPath:"/api/human.html#parseabiparameter-1"});return t}const l=32;function C(e=0){var t;if(((t=globalThis.Buffer)===null||t===void 0?void 0:t.alloc)!==void 0){const n=globalThis.Buffer.alloc(e);return new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}return new Uint8Array(e)}function ee(e){var t,n;return Object.assign(Object.assign({},e),{name:(t=e.name)!==null&&t!==void 0?t:"",components:(n=e.components)===null||n===void 0?void 0:n.map(r=>ee(r))})}function Ye(e){return!p(e)&&typeof e=="object"&&!p(e.type)&&typeof e.type=="string"}function te(e){return e.map(t=>{var n;if(Ye(t))return t;if(typeof t=="string")return ee(Xe(t.replace(/tuple/,"")));if(Oe(t)){const r=Object.keys(t)[0],s=G(r);return s.name=(n=s.name)!==null&&n!==void 0?n:"",Object.assign(Object.assign({},s),{components:K(t[r])})}throw new c("Invalid abi")})}function z(e){const t=e.type.lastIndexOf("["),n=e.type.substring(0,t),r=e.type.substring(t);let s=-1;if(r!=="[]"&&(s=Number(r.slice(1,-1)),isNaN(s)))throw new c("Invalid fixed array size",{size:r});return{param:{type:n,name:"",components:e.components},size:s}}function T(e){var t,n;return e.type==="string"||e.type==="bytes"||e.type.endsWith("[]")?!0:e.type==="tuple"?(n=(t=e.components)===null||t===void 0?void 0:t.some(T))!==null&&n!==void 0?n:!1:e.type.endsWith("]")?T(z(e).param):!1}const ne=20,re=l-ne;function qe(e,t){if(typeof t!="string")throw new c("address type expects string as input type",{value:t,name:e.name,type:e.type});let n=t.toLowerCase();if(n.startsWith("0x")||(n="0x".concat(n)),!be(n))throw new c("provided input is not valid address",{value:t,name:e.name,type:e.type});const r=k(n),s=C(l);return s.set(r,re),{dynamic:!1,encoded:s}}function Je(e,t){const n=t.subarray(re,l);if(n.length!==ne)throw new c("Invalid decoding input, not enough bytes to decode address",{bytes:t});const r=E(n);return{result:ge(r),encoded:t.subarray(l),consumed:l}}const g=new Map;let $=BigInt(256);for(let e=8;e<=256;e+=8)g.set("uint".concat(e),{min:BigInt(0),max:$-BigInt(1)}),g.set("int".concat(e),{min:-$/BigInt(2),max:$/BigInt(2)-BigInt(1)}),$*=BigInt(256);g.set("int",g.get("int256"));g.set("uint",g.get("uint256"));const se=BigInt(1)<<BigInt(256);function Qe(e,t=l){let n;return e<0?n=(se+e).toString(16):n=e.toString(16),n=we(n,t*2),k(n)}function et(e,t){const n=E(e),r=BigInt(n);return r<=t?r:r-se}function I(e,t){let n;try{n=ve(t)}catch(s){throw new c("provided input is not number value",{type:e.type,value:t,name:e.name})}const r=g.get(e.type);if(!r)throw new c("provided abi contains invalid number datatype",{type:e.type});if(n<r.min)throw new c("provided input is less then minimum for given type",{type:e.type,value:t,name:e.name,minimum:r.min.toString()});if(n>r.max)throw new c("provided input is greater then maximum for given type",{type:e.type,value:t,name:e.name,maximum:r.max.toString()});return{dynamic:!1,encoded:Qe(n)}}function v(e,t){if(t.length<l)throw new c("Not enough bytes left to decode",{param:e,bytesLeft:t.length});const n=t.subarray(0,l),r=g.get(e.type);if(!r)throw new c("provided abi contains invalid number datatype",{type:e.type});const s=et(n,r.max);if(s<r.min)throw new c("decoded value is less then minimum for given type",{type:e.type,value:s,name:e.name,minimum:r.min.toString()});if(s>r.max)throw new c("decoded value is greater then maximum for given type",{type:e.type,value:s,name:e.name,maximum:r.max.toString()});return{result:s,encoded:t.subarray(l),consumed:l}}function tt(e,t){let n;try{n=Ae(t)}catch(r){if(r instanceof xe)throw new c("provided input is not valid boolean value",{type:e.type,value:t,name:e.name})}return I({type:"uint8",name:""},Number(n))}function nt(e,t){const n=v({type:"uint8",name:""},t);if(n.result>1||n.result<0)throw new c("Invalid boolean value encoded",{boolBytes:t.subarray(0,l),numberResult:n});return{result:n.result===BigInt(1),encoded:n.encoded,consumed:l}}const rt=32;function ie(e,t){if(typeof t=="string"&&t.length%2!==0&&(t+="0"),!_e(t))throw new c("provided input is not valid bytes value",{type:e.type,value:t,name:e.name});const n=$e(t),[,r]=e.type.split("bytes");if(r){if(Number(r)>rt||Number(r)<1)throw new c("invalid bytes type. Static byte type can have between 1 and 32 bytes",{type:e.type});if(Number(r)<n.length)throw new c("provided input size is different than type size",{type:e.type,value:t,name:e.name});const a=C(l);return a.set(n),{dynamic:!1,encoded:a}}const s=Math.ceil(n.length/l),i=C(l+s*l);return i.set(I({type:"uint32",name:""},n.length).encoded),i.set(n,l),{dynamic:!0,encoded:i}}function oe(e,t){const[,n]=e.type.split("bytes");let r=Number(n),s=t,i=1,a=0;if(!r){const o=v({type:"uint32",name:""},s);r=Number(o.result),a+=o.consumed,s=o.encoded,i=Math.ceil(r/l)}if(r>t.length)throw new c("there is not enough data to decode",{type:e.type,encoded:t,size:r});return{result:Ie(s.subarray(0,r)),encoded:s.subarray(i*l),consumed:a+i*l}}function st(e,t){if(typeof t!="string")throw new c("invalid input, should be string",{input:t});const n=Se(t);return ie({type:"bytes",name:""},n)}function it(e,t){const n=oe({type:"bytes",name:""},t);return{result:Pe(n.result),encoded:n.encoded,consumed:n.consumed}}function ae(e){let t=0,n=0;const r=[],s=[];for(const i of e)i.dynamic?t+=l:t+=i.encoded.length;for(const i of e)i.dynamic?(r.push(I({type:"uint256",name:""},t+n)),s.push(i),n+=i.encoded.length):r.push(i);return P(...r.map(i=>i.encoded),...s.map(i=>i.encoded))}function ot(e,t){if(!Array.isArray(t))throw new c("Expected value to be array",{abi:e,values:t});const{size:n,param:r}=z(e),s=t.map(o=>j(r,o)),i=n===-1,a=s.length>0&&s[0].dynamic;if(!i&&t.length!==n)throw new c("Given arguments count doesn't match array length",{arrayLength:n,argumentsLength:t.length});if(i||a){const o=ae(s);if(i){const d=I({type:"uint256",name:""},s.length).encoded;return{dynamic:!0,encoded:s.length>0?P(d,o):d}}return{dynamic:!0,encoded:o}}return{dynamic:!1,encoded:P(...s.map(o=>o.encoded))}}function at(e,t){let{size:n,param:r}=z(e);const s=n===-1;let i=0;const a=[];let o=t;if(s){const u=v({type:"uint32",name:""},t);n=Number(u.result),i=u.consumed,o=u.encoded}if(T(r)){for(let u=0;u<n;u+=1){const y=v({type:"uint32",name:""},o.subarray(u*l));i+=y.consumed;const f=B(r,o.subarray(Number(y.result)));i+=f.consumed,a.push(f.result)}return{result:a,encoded:o.subarray(i),consumed:i}}for(let u=0;u<n;u+=1){const y=B(r,t.subarray(i));i+=y.consumed,a.push(y.result)}return{result:a,encoded:t.subarray(i),consumed:i}}function j(e,t){if(e.type==="string")return st(e,t);if(e.type==="bool")return tt(e,t);if(e.type==="address")return qe(e,t);if(e.type==="tuple")return F(e,t);if(e.type.endsWith("]"))return ot(e,t);if(e.type.startsWith("bytes"))return ie(e,t);if(e.type.startsWith("uint")||e.type.startsWith("int"))return I(e,t);throw new c("Unsupported",{param:e,value:t})}function B(e,t){if(e.type==="string")return it(e,t);if(e.type==="bool")return nt(e,t);if(e.type==="address")return Je(e,t);if(e.type==="tuple")return ce(e,t);if(e.type.endsWith("]"))return at(e,t);if(e.type.startsWith("bytes"))return oe(e,t);if(e.type.startsWith("uint")||e.type.startsWith("int"))return v(e,t);throw new c("Unsupported",{param:e,bytes:t})}function F(e,t){var n,r,s;let i=!1;if(!Array.isArray(t)&&typeof t!="object")throw new c("param must be either Array or Object",{param:e,input:t});const a=t,o=[];for(let d=0;d<((r=(n=e.components)===null||n===void 0?void 0:n.length)!==null&&r!==void 0?r:0);d+=1){const u=e.components[d];let y;if(Array.isArray(a)){if(d>=a.length)throw new c("input param length missmatch",{param:e,input:t});y=j(u,a[d])}else{const f=a[(s=u.name)!==null&&s!==void 0?s:""];if(f==null)throw new c("missing input defined in abi",{param:e,input:t,paramName:u.name});y=j(u,f)}y.dynamic&&(i=!0),o.push(y)}return i?{dynamic:!0,encoded:ae(o)}:{dynamic:!1,encoded:P(...o.map(d=>d.encoded))}}function ce(e,t){const n={__length__:0};let r=0;if(!e.components)return{result:n,encoded:t,consumed:r};let s=0;for(const[i,a]of e.components.entries()){let o;if(T(a)){const d=v({type:"uint32",name:""},t.subarray(r));o=B(a,t.subarray(Number(d.result))),r+=d.consumed,s+=o.consumed}else o=B(a,t.subarray(r)),r+=o.consumed;n.__length__+=1,n[i]=o.result,a.name&&a.name!==""&&(n[a.name]=o.result)}return{encoded:t.subarray(r+s),result:n,consumed:r+s}}function ct(e,t,n){const r=te(e),s=k(t);return ce({type:"tuple",name:"",components:r},s).result}function de(e){const t=[];return e.forEach(n=>{if(Array.isArray(n)){const r=de(n);t.push({type:"tuple",components:r,name:""})}else t.push({type:Te(n,!0)})}),t}function dt(e,t){if((e==null?void 0:e.length)!==t.length)throw new c("Invalid number of values received for given ABI",{expected:e==null?void 0:e.length,received:t.length});const n=te(e);return E(F({type:"tuple",name:"",components:n},t).encoded)}function wt(e){try{const t=de(e);return E(F({type:"tuple",name:"",components:t},e).encoded)}catch(t){throw new c("Could not infer types from given params",{params:e})}}const At=(e,t)=>dt([e],[t]),ut=(e,t,n)=>{try{if(e.length>0&&(!t||t==="0x"||t==="0X"))throw new c("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");return ct(e,"0x".concat(t.replace(/0x/i,"")),n)}catch(r){throw new c("Parameter decoding error: ".concat(r.message),{internalErr:r})}},lt=(e,t)=>ut(e,t,!1),xt=(e,t)=>lt([e],t)[0],It=e=>{if(typeof e!="string"&&!Z(e))throw new c("Invalid parameter value in encodeFunctionSignature");let t;return e&&(typeof e=="function"||typeof e=="object")?t=Me(e):t=e,Be(t).slice(0,10)};export{c as A,gt as E,ft as F,mt as M,pt as O,Ee as a,Re as b,ut as c,lt as d,It as e,xt as f,ht as g,At as h,p as i,Me as j,dt as k,wt as l,vt as m,bt as n,Z as o};
