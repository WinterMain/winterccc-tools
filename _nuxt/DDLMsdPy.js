var z={},d={};Object.defineProperty(d,"__esModule",{value:!0});d.crypto=void 0;d.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var i={};Object.defineProperty(i,"__esModule",{value:!0});i.output=i.exists=i.hash=i.bytes=i.bool=i.number=i.isBytes=void 0;function l(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, not ".concat(e))}i.number=l;function _(e){if(typeof e!="boolean")throw new Error("boolean expected, not ".concat(e))}i.bool=_;function B(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}i.isBytes=B;function w(e,...f){if(!B(e))throw new Error("Uint8Array expected");if(f.length>0&&!f.includes(e.length))throw new Error("Uint8Array expected of length ".concat(f,", not of length=").concat(e.length))}i.bytes=w;function L(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");l(e.outputLen),l(e.blockLen)}i.hash=L;function m(e,f=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(f&&e.finished)throw new Error("Hash#digest() has already been called")}i.exists=m;function O(e,f){w(e);const a=f.outputLen;if(e.length<a)throw new Error("digestInto() expects output buffer of length at least ".concat(a))}i.output=O;const G={number:l,bool:_,bytes:w,hash:L,exists:m,output:O};i.default=G;(function(e){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.byteSwap32=e.byteSwapIfBE=e.byteSwap=e.isLE=e.rotl=e.rotr=e.createView=e.u32=e.u8=e.isBytes=void 0;const f=d,a=i;function A(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}e.isBytes=A;const E=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e.u8=E;const T=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4));e.u32=T;const S=t=>new DataView(t.buffer,t.byteOffset,t.byteLength);e.createView=S;const k=(t,n)=>t<<32-n|t>>>n;e.rotr=k;const U=(t,n)=>t<<n|t>>>32-n>>>0;e.rotl=U,e.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;const j=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;e.byteSwap=j,e.byteSwapIfBE=e.isLE?t=>t:t=>(0,e.byteSwap)(t);function v(t){for(let n=0;n<t.length;n++)t[n]=(0,e.byteSwap)(t[n])}e.byteSwap32=v;const C=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function H(t){(0,a.bytes)(t);let n="";for(let r=0;r<t.length;r++)n+=C[t[r]];return n}e.bytesToHex=H;const s={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function b(t){if(t>=s._0&&t<=s._9)return t-s._0;if(t>=s._A&&t<=s._F)return t-(s._A-10);if(t>=s._a&&t<=s._f)return t-(s._a-10)}function V(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,r=n/2;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const o=new Uint8Array(r);for(let c=0,u=0;c<r;c++,u+=2){const g=b(t.charCodeAt(u)),p=b(t.charCodeAt(u+1));if(g===void 0||p===void 0){const q=t[u]+t[u+1];throw new Error('hex string expected, got non-hex character "'+q+'" at index '+u)}o[c]=g*16+p}return o}e.hexToBytes=V;const W=async()=>{};e.nextTick=W;async function $(t,n,r){let o=Date.now();for(let c=0;c<t;c++){r(c);const u=Date.now()-o;u>=0&&u<n||(await(0,e.nextTick)(),o+=u)}}e.asyncLoop=$;function h(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got ".concat(typeof t));return new Uint8Array(new TextEncoder().encode(t))}e.utf8ToBytes=h;function y(t){return typeof t=="string"&&(t=h(t)),(0,a.bytes)(t),t}e.toBytes=y;function F(...t){let n=0;for(let o=0;o<t.length;o++){const c=t[o];(0,a.bytes)(c),n+=c.length}const r=new Uint8Array(n);for(let o=0,c=0;o<t.length;o++){const u=t[o];r.set(u,c),c+=u.length}return r}e.concatBytes=F;class I{clone(){return this._cloneInto()}}e.Hash=I;const M={}.toString;function D(t,n){if(n!==void 0&&M.call(n)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(t,n)}e.checkOpts=D;function P(t){const n=o=>t().update(y(o)).digest(),r=t();return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=()=>t(),n}e.wrapConstructor=P;function R(t){const n=(o,c)=>t(c).update(y(o)).digest(),r=t({});return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=o=>t(o),n}e.wrapConstructorWithOpts=R;function X(t){const n=(o,c)=>t(c).update(y(o)).digest(),r=t({});return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=o=>t(o),n}e.wrapXOFConstructorWithOpts=X;function N(t=32){if(f.crypto&&typeof f.crypto.getRandomValues=="function")return f.crypto.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}e.randomBytes=N})(z);export{i as _,z as u};
