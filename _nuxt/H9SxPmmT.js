import{a3 as de,bG as Qt}from"./CqK3pOxO.js";import{s as he}from"./Q1DMZ9_U.js";import{h as ye}from"./UpURgLKm.js";var Jt={exports:{}};(function(t){var r=Object.prototype.hasOwnProperty,o="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(o=!1));function f(s,c,g){this.fn=s,this.context=c,this.once=g||!1}function u(s,c,g,E,L){if(typeof g!="function")throw new TypeError("The listener must be a function");var I=new f(g,E||s,L),N=o?o+c:c;return s._events[N]?s._events[N].fn?s._events[N]=[s._events[N],I]:s._events[N].push(I):(s._events[N]=I,s._eventsCount++),s}function m(s,c){--s._eventsCount===0?s._events=new n:delete s._events[c]}function h(){this._events=new n,this._eventsCount=0}h.prototype.eventNames=function(){var c=[],g,E;if(this._eventsCount===0)return c;for(E in g=this._events)r.call(g,E)&&c.push(o?E.slice(1):E);return Object.getOwnPropertySymbols?c.concat(Object.getOwnPropertySymbols(g)):c},h.prototype.listeners=function(c){var g=o?o+c:c,E=this._events[g];if(!E)return[];if(E.fn)return[E.fn];for(var L=0,I=E.length,N=new Array(I);L<I;L++)N[L]=E[L].fn;return N},h.prototype.listenerCount=function(c){var g=o?o+c:c,E=this._events[g];return E?E.fn?1:E.length:0},h.prototype.emit=function(c,g,E,L,I,N){var H=o?o+c:c;if(!this._events[H])return!1;var A=this._events[H],F=arguments.length,a,d;if(A.fn){switch(A.once&&this.removeListener(c,A.fn,void 0,!0),F){case 1:return A.fn.call(A.context),!0;case 2:return A.fn.call(A.context,g),!0;case 3:return A.fn.call(A.context,g,E),!0;case 4:return A.fn.call(A.context,g,E,L),!0;case 5:return A.fn.call(A.context,g,E,L,I),!0;case 6:return A.fn.call(A.context,g,E,L,I,N),!0}for(d=1,a=new Array(F-1);d<F;d++)a[d-1]=arguments[d];A.fn.apply(A.context,a)}else{var e=A.length,U;for(d=0;d<e;d++)switch(A[d].once&&this.removeListener(c,A[d].fn,void 0,!0),F){case 1:A[d].fn.call(A[d].context);break;case 2:A[d].fn.call(A[d].context,g);break;case 3:A[d].fn.call(A[d].context,g,E);break;case 4:A[d].fn.call(A[d].context,g,E,L);break;default:if(!a)for(U=1,a=new Array(F-1);U<F;U++)a[U-1]=arguments[U];A[d].fn.apply(A[d].context,a)}}return!0},h.prototype.on=function(c,g,E){return u(this,c,g,E,!1)},h.prototype.once=function(c,g,E){return u(this,c,g,E,!0)},h.prototype.removeListener=function(c,g,E,L){var I=o?o+c:c;if(!this._events[I])return this;if(!g)return m(this,I),this;var N=this._events[I];if(N.fn)N.fn===g&&(!L||N.once)&&(!E||N.context===E)&&m(this,I);else{for(var H=0,A=[],F=N.length;H<F;H++)(N[H].fn!==g||L&&!N[H].once||E&&N[H].context!==E)&&A.push(N[H]);A.length?this._events[I]=A.length===1?A[0]:A:m(this,I)}return this},h.prototype.removeAllListeners=function(c){var g;return c?(g=o?o+c:c,this._events[g]&&m(this,g)):(this._events=new n,this._eventsCount=0),this},h.prototype.off=h.prototype.removeListener,h.prototype.addListener=h.prototype.on,h.prefixed=o,h.EventEmitter=h,t.exports=h})(Jt);var me=Jt.exports;const cn=de(me);var be={},St={},Ut={},Tt={},K={},V={};Object.defineProperty(V,"__esModule",{value:!0});V.bitMask=void 0;V.isBytes=Ot;V.abytes=It;V.bytesToHex=jt;V.numberToHexUnpadded=te;V.hexToNumber=kt;V.hexToBytes=Nt;V.bytesToNumberBE=Ee;V.bytesToNumberLE=pe;V.numberToBytesBE=ee;V.numberToBytesLE=ve;V.numberToVarBytesBE=Be;V.ensureBytes=_e;V.concatBytes=ne;V.equalBytes=xe;V.utf8ToBytes=Se;V.bitLen=Te;V.bitGet=Ae;V.bitSet=Oe;V.createHmacDrbg=Ne;V.validateObject=Re;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=BigInt(0),At=BigInt(1),ge=BigInt(2);function Ot(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function It(t){if(!Ot(t))throw new Error("Uint8Array expected")}const we=Array.from({length:256},(t,r)=>r.toString(16).padStart(2,"0"));function jt(t){It(t);let r="";for(let o=0;o<t.length;o++)r+=we[t[o]];return r}function te(t){const r=t.toString(16);return r.length&1?"0".concat(r):r}function kt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":"0x".concat(t))}const ht={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function zt(t){if(t>=ht._0&&t<=ht._9)return t-ht._0;if(t>=ht._A&&t<=ht._F)return t-(ht._A-10);if(t>=ht._a&&t<=ht._f)return t-(ht._a-10)}function Nt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const r=t.length,o=r/2;if(r%2)throw new Error("padded hex string expected, got unpadded hex of length "+r);const n=new Uint8Array(o);for(let f=0,u=0;f<o;f++,u+=2){const m=zt(t.charCodeAt(u)),h=zt(t.charCodeAt(u+1));if(m===void 0||h===void 0){const s=t[u]+t[u+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+u)}n[f]=m*16+h}return n}function Ee(t){return kt(jt(t))}function pe(t){return It(t),kt(jt(Uint8Array.from(t).reverse()))}function ee(t,r){return Nt(t.toString(16).padStart(r*2,"0"))}function ve(t,r){return ee(t,r).reverse()}function Be(t){return Nt(te(t))}function _e(t,r,o){let n;if(typeof r=="string")try{n=Nt(r)}catch(u){throw new Error("".concat(t,' must be valid hex string, got "').concat(r,'". Cause: ').concat(u))}else if(Ot(r))n=Uint8Array.from(r);else throw new Error("".concat(t," must be hex string or Uint8Array"));const f=n.length;if(typeof o=="number"&&f!==o)throw new Error("".concat(t," expected ").concat(o," bytes, got ").concat(f));return n}function ne(...t){let r=0;for(let n=0;n<t.length;n++){const f=t[n];It(f),r+=f.length}const o=new Uint8Array(r);for(let n=0,f=0;n<t.length;n++){const u=t[n];o.set(u,f),f+=u.length}return o}function xe(t,r){if(t.length!==r.length)return!1;let o=0;for(let n=0;n<t.length;n++)o|=t[n]^r[n];return o===0}function Se(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got ".concat(typeof t));return new Uint8Array(new TextEncoder().encode(t))}function Te(t){let r;for(r=0;t>Ft;t>>=At,r+=1);return r}function Ae(t,r){return t>>BigInt(r)&At}function Oe(t,r,o){return t|(o?At:Ft)<<BigInt(r)}const Ie=t=>(ge<<BigInt(t-1))-At;V.bitMask=Ie;const Rt=t=>new Uint8Array(t),Kt=t=>Uint8Array.from(t);function Ne(t,r,o){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof r!="number"||r<2)throw new Error("qByteLen must be a number");if(typeof o!="function")throw new Error("hmacFn must be a function");let n=Rt(t),f=Rt(t),u=0;const m=()=>{n.fill(1),f.fill(0),u=0},h=(...E)=>o(f,n,...E),s=(E=Rt())=>{f=h(Kt([0]),E),n=h(),E.length!==0&&(f=h(Kt([1]),E),n=h())},c=()=>{if(u++>=1e3)throw new Error("drbg: tried 1000 values");let E=0;const L=[];for(;E<r;){n=h();const I=n.slice();L.push(I),E+=n.length}return ne(...L)};return(E,L)=>{m(),s(E);let I;for(;!(I=L(c()));)s();return m(),I}}const qe={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||Ot(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,r)=>r.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Re(t,r,o={}){const n=(f,u,m)=>{const h=qe[u];if(typeof h!="function")throw new Error('Invalid validator "'.concat(u,'", expected function'));const s=t[f];if(!(m&&s===void 0)&&!h(s,t))throw new Error("Invalid param ".concat(String(f),"=").concat(s," (").concat(typeof s,"), expected ").concat(u))};for(const[f,u]of Object.entries(r))n(f,u,!1);for(const[f,u]of Object.entries(o))n(f,u,!0);return t}Object.defineProperty(K,"__esModule",{value:!0});K.isNegativeLE=void 0;K.mod=at;K.pow=re;K.pow2=Ce;K.invert=xt;K.tonelliShanks=oe;K.FpSqrt=se;K.validateField=je;K.FpPow=ie;K.FpInvertBatch=ce;K.FpDiv=ke;K.FpIsSquare=Pe;K.nLength=Pt;K.Field=Ze;K.FpSqrtOdd=Ve;K.FpSqrtEven=He;K.hashToPrivateScalar=Me;K.getFieldBytesLength=Zt;K.getMinHashLength=ae;K.mapHashToField=De;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ft=V,et=BigInt(0),z=BigInt(1),gt=BigInt(2),Le=BigInt(3),Ct=BigInt(4),Yt=BigInt(5),Gt=BigInt(8);BigInt(9);BigInt(16);function at(t,r){const o=t%r;return o>=et?o:r+o}function re(t,r,o){if(o<=et||r<et)throw new Error("Expected power/modulo > 0");if(o===z)return et;let n=z;for(;r>et;)r&z&&(n=n*t%o),t=t*t%o,r>>=z;return n}function Ce(t,r,o){let n=t;for(;r-- >et;)n*=n,n%=o;return n}function xt(t,r){if(t===et||r<=et)throw new Error("invert: expected positive integers, got n=".concat(t," mod=").concat(r));let o=at(t,r),n=r,f=et,u=z;for(;o!==et;){const h=n/o,s=n%o,c=f-u*h;n=o,o=s,f=u,u=c}if(n!==z)throw new Error("invert: does not exist");return at(f,r)}function oe(t){const r=(t-z)/gt;let o,n,f;for(o=t-z,n=0;o%gt===et;o/=gt,n++);for(f=gt;f<t&&re(f,r,t)!==t-z;f++);if(n===1){const m=(t+z)/Ct;return function(s,c){const g=s.pow(c,m);if(!s.eql(s.sqr(g),c))throw new Error("Cannot find square root");return g}}const u=(o+z)/gt;return function(h,s){if(h.pow(s,r)===h.neg(h.ONE))throw new Error("Cannot find square root");let c=n,g=h.pow(h.mul(h.ONE,f),o),E=h.pow(s,u),L=h.pow(s,o);for(;!h.eql(L,h.ONE);){if(h.eql(L,h.ZERO))return h.ZERO;let I=1;for(let H=h.sqr(L);I<c&&!h.eql(H,h.ONE);I++)H=h.sqr(H);const N=h.pow(g,z<<BigInt(c-I-1));g=h.sqr(N),E=h.mul(E,N),L=h.mul(L,g),c=I}return E}}function se(t){if(t%Ct===Le){const r=(t+z)/Ct;return function(n,f){const u=n.pow(f,r);if(!n.eql(n.sqr(u),f))throw new Error("Cannot find square root");return u}}if(t%Gt===Yt){const r=(t-Yt)/Gt;return function(n,f){const u=n.mul(f,gt),m=n.pow(u,r),h=n.mul(f,m),s=n.mul(n.mul(h,gt),m),c=n.mul(h,n.sub(s,n.ONE));if(!n.eql(n.sqr(c),f))throw new Error("Cannot find square root");return c}}return oe(t)}const $e=(t,r)=>(at(t,r)&z)===z;K.isNegativeLE=$e;const Ue=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function je(t){const r={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},o=Ue.reduce((n,f)=>(n[f]="function",n),r);return(0,ft.validateObject)(t,o)}function ie(t,r,o){if(o<et)throw new Error("Expected power > 0");if(o===et)return t.ONE;if(o===z)return r;let n=t.ONE,f=r;for(;o>et;)o&z&&(n=t.mul(n,f)),f=t.sqr(f),o>>=z;return n}function ce(t,r){const o=new Array(r.length),n=r.reduce((u,m,h)=>t.is0(m)?u:(o[h]=u,t.mul(u,m)),t.ONE),f=t.inv(n);return r.reduceRight((u,m,h)=>t.is0(m)?u:(o[h]=t.mul(u,o[h]),t.mul(u,m)),f),o}function ke(t,r,o){return t.mul(r,typeof o=="bigint"?xt(o,t.ORDER):t.inv(o))}function Pe(t){const r=(t.ORDER-z)/gt;return o=>{const n=t.pow(o,r);return t.eql(n,t.ZERO)||t.eql(n,t.ONE)}}function Pt(t,r){const o=r!==void 0?r:t.toString(2).length,n=Math.ceil(o/8);return{nBitLength:o,nByteLength:n}}function Ze(t,r,o=!1,n={}){if(t<=et)throw new Error("Expected Field ORDER > 0, got ".concat(t));const{nBitLength:f,nByteLength:u}=Pt(t,r);if(u>2048)throw new Error("Field lengths over 2048 bytes are not supported");const m=se(t),h=Object.freeze({ORDER:t,BITS:f,BYTES:u,MASK:(0,ft.bitMask)(f),ZERO:et,ONE:z,create:s=>at(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error("Invalid field element: expected bigint, got ".concat(typeof s));return et<=s&&s<t},is0:s=>s===et,isOdd:s=>(s&z)===z,neg:s=>at(-s,t),eql:(s,c)=>s===c,sqr:s=>at(s*s,t),add:(s,c)=>at(s+c,t),sub:(s,c)=>at(s-c,t),mul:(s,c)=>at(s*c,t),pow:(s,c)=>ie(h,s,c),div:(s,c)=>at(s*xt(c,t),t),sqrN:s=>s*s,addN:(s,c)=>s+c,subN:(s,c)=>s-c,mulN:(s,c)=>s*c,inv:s=>xt(s,t),sqrt:n.sqrt||(s=>m(h,s)),invertBatch:s=>ce(h,s),cmov:(s,c,g)=>g?c:s,toBytes:s=>o?(0,ft.numberToBytesLE)(s,u):(0,ft.numberToBytesBE)(s,u),fromBytes:s=>{if(s.length!==u)throw new Error("Fp.fromBytes: expected ".concat(u,", got ").concat(s.length));return o?(0,ft.bytesToNumberLE)(s):(0,ft.bytesToNumberBE)(s)}});return Object.freeze(h)}function Ve(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const o=t.sqrt(r);return t.isOdd(o)?o:t.neg(o)}function He(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const o=t.sqrt(r);return t.isOdd(o)?t.neg(o):o}function Me(t,r,o=!1){t=(0,ft.ensureBytes)("privateHash",t);const n=t.length,f=Pt(r).nByteLength+8;if(f<24||n<f||n>1024)throw new Error("hashToPrivateScalar: expected ".concat(f,"-1024 bytes of input, got ").concat(n));const u=o?(0,ft.bytesToNumberLE)(t):(0,ft.bytesToNumberBE)(t);return at(u,r-z)+z}function Zt(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const r=t.toString(2).length;return Math.ceil(r/8)}function ae(t){const r=Zt(t);return r+Math.ceil(r/2)}function De(t,r,o=!1){const n=t.length,f=Zt(r),u=ae(r);if(n<16||n<u||n>1024)throw new Error("expected ".concat(u,"-1024 bytes of input, got ").concat(n));const m=o?(0,ft.bytesToNumberBE)(t):(0,ft.bytesToNumberLE)(t),h=at(m,r-z)+z;return o?(0,ft.numberToBytesLE)(h,f):(0,ft.numberToBytesBE)(h,f)}Object.defineProperty(Tt,"__esModule",{value:!0});Tt.wNAF=Ye;Tt.validateBasic=Ge;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wt=K,ze=V,Ke=BigInt(0),Lt=BigInt(1);function Ye(t,r){const o=(f,u)=>{const m=u.negate();return f?m:u},n=f=>{const u=Math.ceil(r/f)+1,m=2**(f-1);return{windows:u,windowSize:m}};return{constTimeNegate:o,unsafeLadder(f,u){let m=t.ZERO,h=f;for(;u>Ke;)u&Lt&&(m=m.add(h)),h=h.double(),u>>=Lt;return m},precomputeWindow(f,u){const{windows:m,windowSize:h}=n(u),s=[];let c=f,g=c;for(let E=0;E<m;E++){g=c,s.push(g);for(let L=1;L<h;L++)g=g.add(c),s.push(g);c=g.double()}return s},wNAF(f,u,m){const{windows:h,windowSize:s}=n(f);let c=t.ZERO,g=t.BASE;const E=BigInt(2**f-1),L=2**f,I=BigInt(f);for(let N=0;N<h;N++){const H=N*s;let A=Number(m&E);m>>=I,A>s&&(A-=L,m+=Lt);const F=H,a=H+Math.abs(A)-1,d=N%2!==0,e=A<0;A===0?g=g.add(o(d,u[F])):c=c.add(o(e,u[a]))}return{p:c,f:g}},wNAFCached(f,u,m,h){const s=f._WINDOW_SIZE||1;let c=u.get(f);return c||(c=this.precomputeWindow(f,s),s!==1&&u.set(f,h(c))),this.wNAF(s,c,m)}}}function Ge(t){return(0,Wt.validateField)(t.Fp),(0,ze.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,Wt.nLength)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}(function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.DER=void 0,t.weierstrassPoints=I,t.weierstrass=H,t.SWUFpSqrtRatio=A,t.mapToCurveSimpleSWU=F;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const r=Tt,o=K,n=V,f=V;function u(a){const d=(0,r.validateBasic)(a);n.validateObject(d,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:U,a:M}=d;if(e){if(!U.eql(M,U.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...d})}const{bytesToNumberBE:m,hexToBytes:h}=n;t.DER={Err:class extends Error{constructor(d=""){super(d)}},_parseInt(a){const{Err:d}=t.DER;if(a.length<2||a[0]!==2)throw new d("Invalid signature integer tag");const e=a[1],U=a.subarray(2,e+2);if(!e||U.length!==e)throw new d("Invalid signature integer: wrong length");if(U[0]&128)throw new d("Invalid signature integer: negative");if(U[0]===0&&!(U[1]&128))throw new d("Invalid signature integer: unnecessary leading zero");return{d:m(U),l:a.subarray(e+2)}},toSig(a){const{Err:d}=t.DER,e=typeof a=="string"?h(a):a;n.abytes(e);let U=e.length;if(U<2||e[0]!=48)throw new d("Invalid signature tag");if(e[1]!==U-2)throw new d("Invalid signature: incorrect length");const{d:M,l:j}=t.DER._parseInt(e.subarray(2)),{d:G,l:k}=t.DER._parseInt(j);if(k.length)throw new d("Invalid signature: left bytes after parsing");return{r:M,s:G}},hexFromSig(a){const d=P=>Number.parseInt(P[0],16)&8?"00"+P:P,e=P=>{const W=P.toString(16);return W.length&1?"0".concat(W):W},U=d(e(a.s)),M=d(e(a.r)),j=U.length/2,G=M.length/2,k=e(j),tt=e(G);return"30".concat(e(G+j+4),"02").concat(tt).concat(M,"02").concat(k).concat(U)}};const s=BigInt(0),c=BigInt(1),g=BigInt(2),E=BigInt(3),L=BigInt(4);function I(a){const d=u(a),{Fp:e}=d,U=d.toBytes||((R,y,p)=>{const i=y.toAffine();return n.concatBytes(Uint8Array.from([4]),e.toBytes(i.x),e.toBytes(i.y))}),M=d.fromBytes||(R=>{const y=R.subarray(1),p=e.fromBytes(y.subarray(0,e.BYTES)),i=e.fromBytes(y.subarray(e.BYTES,2*e.BYTES));return{x:p,y:i}});function j(R){const{a:y,b:p}=d,i=e.sqr(R),l=e.mul(i,R);return e.add(e.add(l,e.mul(R,y)),p)}if(!e.eql(e.sqr(d.Gy),j(d.Gx)))throw new Error("bad generator point: equation left != right");function G(R){return typeof R=="bigint"&&s<R&&R<d.n}function k(R){if(!G(R))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function tt(R){const{allowedPrivateKeyLengths:y,nByteLength:p,wrapPrivateKey:i,n:l}=d;if(y&&typeof R!="bigint"){if(n.isBytes(R)&&(R=n.bytesToHex(R)),typeof R!="string"||!y.includes(R.length))throw new Error("Invalid key");R=R.padStart(p*2,"0")}let w;try{w=typeof R=="bigint"?R:n.bytesToNumberBE((0,f.ensureBytes)("private key",R,p))}catch(B){throw new Error("private key must be ".concat(p," bytes, hex or bigint, not ").concat(typeof R))}return i&&(w=o.mod(w,l)),k(w),w}const P=new Map;function W(R){if(!(R instanceof q))throw new Error("ProjectivePoint expected")}class q{constructor(y,p,i){if(this.px=y,this.py=p,this.pz=i,y==null||!e.isValid(y))throw new Error("x required");if(p==null||!e.isValid(p))throw new Error("y required");if(i==null||!e.isValid(i))throw new Error("z required")}static fromAffine(y){const{x:p,y:i}=y||{};if(!y||!e.isValid(p)||!e.isValid(i))throw new Error("invalid affine point");if(y instanceof q)throw new Error("projective point not allowed");const l=w=>e.eql(w,e.ZERO);return l(p)&&l(i)?q.ZERO:new q(p,i,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){const p=e.invertBatch(y.map(i=>i.pz));return y.map((i,l)=>i.toAffine(p[l])).map(q.fromAffine)}static fromHex(y){const p=q.fromAffine(M((0,f.ensureBytes)("pointHex",y)));return p.assertValidity(),p}static fromPrivateKey(y){return q.BASE.multiply(tt(y))}_setWindowSize(y){this._WINDOW_SIZE=y,P.delete(this)}assertValidity(){if(this.is0()){if(d.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:y,y:p}=this.toAffine();if(!e.isValid(y)||!e.isValid(p))throw new Error("bad point: x or y not FE");const i=e.sqr(p),l=j(y);if(!e.eql(i,l))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y}=this.toAffine();if(e.isOdd)return!e.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){W(y);const{px:p,py:i,pz:l}=this,{px:w,py:B,pz:T}=y,_=e.eql(e.mul(p,T),e.mul(w,l)),x=e.eql(e.mul(i,T),e.mul(B,l));return _&&x}negate(){return new q(this.px,e.neg(this.py),this.pz)}double(){const{a:y,b:p}=d,i=e.mul(p,E),{px:l,py:w,pz:B}=this;let T=e.ZERO,_=e.ZERO,x=e.ZERO,S=e.mul(l,l),Y=e.mul(w,w),C=e.mul(B,B),O=e.mul(l,w);return O=e.add(O,O),x=e.mul(l,B),x=e.add(x,x),T=e.mul(y,x),_=e.mul(i,C),_=e.add(T,_),T=e.sub(Y,_),_=e.add(Y,_),_=e.mul(T,_),T=e.mul(O,T),x=e.mul(i,x),C=e.mul(y,C),O=e.sub(S,C),O=e.mul(y,O),O=e.add(O,x),x=e.add(S,S),S=e.add(x,S),S=e.add(S,C),S=e.mul(S,O),_=e.add(_,S),C=e.mul(w,B),C=e.add(C,C),S=e.mul(C,O),T=e.sub(T,S),x=e.mul(C,Y),x=e.add(x,x),x=e.add(x,x),new q(T,_,x)}add(y){W(y);const{px:p,py:i,pz:l}=this,{px:w,py:B,pz:T}=y;let _=e.ZERO,x=e.ZERO,S=e.ZERO;const Y=d.a,C=e.mul(d.b,E);let O=e.mul(p,w),X=e.mul(i,B),Q=e.mul(l,T),rt=e.add(p,i),b=e.add(w,B);rt=e.mul(rt,b),b=e.add(O,X),rt=e.sub(rt,b),b=e.add(p,l);let v=e.add(w,T);return b=e.mul(b,v),v=e.add(O,Q),b=e.sub(b,v),v=e.add(i,l),_=e.add(B,T),v=e.mul(v,_),_=e.add(X,Q),v=e.sub(v,_),S=e.mul(Y,b),_=e.mul(C,Q),S=e.add(_,S),_=e.sub(X,S),S=e.add(X,S),x=e.mul(_,S),X=e.add(O,O),X=e.add(X,O),Q=e.mul(Y,Q),b=e.mul(C,b),X=e.add(X,Q),Q=e.sub(O,Q),Q=e.mul(Y,Q),b=e.add(b,Q),O=e.mul(X,b),x=e.add(x,O),O=e.mul(v,b),_=e.mul(rt,_),_=e.sub(_,O),O=e.mul(rt,X),S=e.mul(v,S),S=e.add(S,O),new q(_,x,S)}subtract(y){return this.add(y.negate())}is0(){return this.equals(q.ZERO)}wNAF(y){return nt.wNAFCached(this,P,y,p=>{const i=e.invertBatch(p.map(l=>l.pz));return p.map((l,w)=>l.toAffine(i[w])).map(q.fromAffine)})}multiplyUnsafe(y){const p=q.ZERO;if(y===s)return p;if(k(y),y===c)return this;const{endo:i}=d;if(!i)return nt.unsafeLadder(this,y);let{k1neg:l,k1:w,k2neg:B,k2:T}=i.splitScalar(y),_=p,x=p,S=this;for(;w>s||T>s;)w&c&&(_=_.add(S)),T&c&&(x=x.add(S)),S=S.double(),w>>=c,T>>=c;return l&&(_=_.negate()),B&&(x=x.negate()),x=new q(e.mul(x.px,i.beta),x.py,x.pz),_.add(x)}multiply(y){k(y);let p=y,i,l;const{endo:w}=d;if(w){const{k1neg:B,k1:T,k2neg:_,k2:x}=w.splitScalar(p);let{p:S,f:Y}=this.wNAF(T),{p:C,f:O}=this.wNAF(x);S=nt.constTimeNegate(B,S),C=nt.constTimeNegate(_,C),C=new q(e.mul(C.px,w.beta),C.py,C.pz),i=S.add(C),l=Y.add(O)}else{const{p:B,f:T}=this.wNAF(p);i=B,l=T}return q.normalizeZ([i,l])[0]}multiplyAndAddUnsafe(y,p,i){const l=q.BASE,w=(T,_)=>_===s||_===c||!T.equals(l)?T.multiplyUnsafe(_):T.multiply(_),B=w(this,p).add(w(y,i));return B.is0()?void 0:B}toAffine(y){const{px:p,py:i,pz:l}=this,w=this.is0();y==null&&(y=w?e.ONE:e.inv(l));const B=e.mul(p,y),T=e.mul(i,y),_=e.mul(l,y);if(w)return{x:e.ZERO,y:e.ZERO};if(!e.eql(_,e.ONE))throw new Error("invZ was invalid");return{x:B,y:T}}isTorsionFree(){const{h:y,isTorsionFree:p}=d;if(y===c)return!0;if(p)return p(q,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:y,clearCofactor:p}=d;return y===c?this:p?p(q,this):this.multiplyUnsafe(d.h)}toRawBytes(y=!0){return this.assertValidity(),U(q,this,y)}toHex(y=!0){return n.bytesToHex(this.toRawBytes(y))}}q.BASE=new q(d.Gx,d.Gy,e.ONE),q.ZERO=new q(e.ZERO,e.ONE,e.ZERO);const ct=d.nBitLength,nt=(0,r.wNAF)(q,d.endo?Math.ceil(ct/2):ct);return{CURVE:d,ProjectivePoint:q,normPrivateKeyToScalar:tt,weierstrassEquation:j,isWithinCurveOrder:G}}function N(a){const d=(0,r.validateBasic)(a);return n.validateObject(d,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...d})}function H(a){const d=N(a),{Fp:e,n:U}=d,M=e.BYTES+1,j=2*e.BYTES+1;function G(b){return s<b&&b<e.ORDER}function k(b){return o.mod(b,U)}function tt(b){return o.invert(b,U)}const{ProjectivePoint:P,normPrivateKeyToScalar:W,weierstrassEquation:q,isWithinCurveOrder:ct}=I({...d,toBytes(b,v,$){const D=v.toAffine(),Z=e.toBytes(D.x),J=n.concatBytes;return $?J(Uint8Array.from([v.hasEvenY()?2:3]),Z):J(Uint8Array.from([4]),Z,e.toBytes(D.y))},fromBytes(b){const v=b.length,$=b[0],D=b.subarray(1);if(v===M&&($===2||$===3)){const Z=n.bytesToNumberBE(D);if(!G(Z))throw new Error("Point is not on curve");const J=q(Z);let ot;try{ot=e.sqrt(J)}catch(lt){const yt=lt instanceof Error?": "+lt.message:"";throw new Error("Point is not on curve"+yt)}const st=(ot&c)===c;return($&1)===1!==st&&(ot=e.neg(ot)),{x:Z,y:ot}}else if(v===j&&$===4){const Z=e.fromBytes(D.subarray(0,e.BYTES)),J=e.fromBytes(D.subarray(e.BYTES,2*e.BYTES));return{x:Z,y:J}}else throw new Error("Point of length ".concat(v," was invalid. Expected ").concat(M," compressed bytes or ").concat(j," uncompressed bytes"))}}),nt=b=>n.bytesToHex(n.numberToBytesBE(b,d.nByteLength));function R(b){const v=U>>c;return b>v}function y(b){return R(b)?k(-b):b}const p=(b,v,$)=>n.bytesToNumberBE(b.slice(v,$));class i{constructor(v,$,D){this.r=v,this.s=$,this.recovery=D,this.assertValidity()}static fromCompact(v){const $=d.nByteLength;return v=(0,f.ensureBytes)("compactSignature",v,$*2),new i(p(v,0,$),p(v,$,2*$))}static fromDER(v){const{r:$,s:D}=t.DER.toSig((0,f.ensureBytes)("DER",v));return new i($,D)}assertValidity(){if(!ct(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!ct(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(v){return new i(this.r,this.s,v)}recoverPublicKey(v){const{r:$,s:D,recovery:Z}=this,J=x((0,f.ensureBytes)("msgHash",v));if(Z==null||![0,1,2,3].includes(Z))throw new Error("recovery id invalid");const ot=Z===2||Z===3?$+d.n:$;if(ot>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const st=Z&1?"03":"02",ut=P.fromHex(st+nt(ot)),lt=tt(ot),yt=k(-J*lt),_t=k(D*lt),mt=P.BASE.multiplyAndAddUnsafe(ut,yt,_t);if(!mt)throw new Error("point at infinify");return mt.assertValidity(),mt}hasHighS(){return R(this.s)}normalizeS(){return this.hasHighS()?new i(this.r,k(-this.s),this.recovery):this}toDERRawBytes(){return n.hexToBytes(this.toDERHex())}toDERHex(){return t.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return n.hexToBytes(this.toCompactHex())}toCompactHex(){return nt(this.r)+nt(this.s)}}const l={isValidPrivateKey(b){try{return W(b),!0}catch(v){return!1}},normPrivateKeyToScalar:W,randomPrivateKey:()=>{const b=o.getMinHashLength(d.n);return o.mapHashToField(d.randomBytes(b),d.n)},precompute(b=8,v=P.BASE){return v._setWindowSize(b),v.multiply(BigInt(3)),v}};function w(b,v=!0){return P.fromPrivateKey(b).toRawBytes(v)}function B(b){const v=n.isBytes(b),$=typeof b=="string",D=(v||$)&&b.length;return v?D===M||D===j:$?D===2*M||D===2*j:b instanceof P}function T(b,v,$=!0){if(B(b))throw new Error("first arg must be private key");if(!B(v))throw new Error("second arg must be public key");return P.fromHex(v).multiply(W(b)).toRawBytes($)}const _=d.bits2int||function(b){const v=n.bytesToNumberBE(b),$=b.length*8-d.nBitLength;return $>0?v>>BigInt($):v},x=d.bits2int_modN||function(b){return k(_(b))},S=n.bitMask(d.nBitLength);function Y(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(s<=b&&b<S))throw new Error("bigint expected < 2^".concat(d.nBitLength));return n.numberToBytesBE(b,d.nByteLength)}function C(b,v,$=O){if(["recovered","canonical"].some(wt=>wt in $))throw new Error("sign() legacy options not supported");const{hash:D,randomBytes:Z}=d;let{lowS:J,prehash:ot,extraEntropy:st}=$;J==null&&(J=!0),b=(0,f.ensureBytes)("msgHash",b),ot&&(b=(0,f.ensureBytes)("prehashed msgHash",D(b)));const ut=x(b),lt=W(v),yt=[Y(lt),Y(ut)];if(st!=null&&st!==!1){const wt=st===!0?Z(e.BYTES):st;yt.push((0,f.ensureBytes)("extraEntropy",wt))}const _t=n.concatBytes(...yt),mt=ut;function qt(wt){const pt=_(wt);if(!ct(pt))return;const Ht=tt(pt),vt=P.BASE.multiply(pt).toAffine(),dt=k(vt.x);if(dt===s)return;const Bt=k(Ht*k(mt+dt*lt));if(Bt===s)return;let Mt=(vt.x===dt?0:2)|Number(vt.y&c),Dt=Bt;return J&&R(Bt)&&(Dt=y(Bt),Mt^=1),new i(dt,Dt,Mt)}return{seed:_t,k2sig:qt}}const O={lowS:d.lowS,prehash:!1},X={lowS:d.lowS,prehash:!1};function Q(b,v,$=O){const{seed:D,k2sig:Z}=C(b,v,$),J=d;return n.createHmacDrbg(J.hash.outputLen,J.nByteLength,J.hmac)(D,Z)}P.BASE._setWindowSize(8);function rt(b,v,$,D=X){var vt;const Z=b;if(v=(0,f.ensureBytes)("msgHash",v),$=(0,f.ensureBytes)("publicKey",$),"strict"in D)throw new Error("options.strict was renamed to lowS");const{lowS:J,prehash:ot}=D;let st,ut;try{if(typeof Z=="string"||n.isBytes(Z))try{st=i.fromDER(Z)}catch(dt){if(!(dt instanceof t.DER.Err))throw dt;st=i.fromCompact(Z)}else if(typeof Z=="object"&&typeof Z.r=="bigint"&&typeof Z.s=="bigint"){const{r:dt,s:Bt}=Z;st=new i(dt,Bt)}else throw new Error("PARSE");ut=P.fromHex($)}catch(dt){if(dt.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(J&&st.hasHighS())return!1;ot&&(v=d.hash(v));const{r:lt,s:yt}=st,_t=x(v),mt=tt(yt),qt=k(_t*mt),wt=k(lt*mt),pt=(vt=P.BASE.multiplyAndAddUnsafe(ut,qt,wt))==null?void 0:vt.toAffine();return pt?k(pt.x)===lt:!1}return{CURVE:d,getPublicKey:w,getSharedSecret:T,sign:Q,verify:rt,ProjectivePoint:P,Signature:i,utils:l}}function A(a,d){const e=a.ORDER;let U=s;for(let R=e-c;R%g===s;R/=g)U+=c;const M=U,j=g<<M-c-c,G=j*g,k=(e-c)/G,tt=(k-c)/g,P=G-c,W=j,q=a.pow(d,k),ct=a.pow(d,(k+c)/g);let nt=(R,y)=>{let p=q,i=a.pow(y,P),l=a.sqr(i);l=a.mul(l,y);let w=a.mul(R,l);w=a.pow(w,tt),w=a.mul(w,i),i=a.mul(w,y),l=a.mul(w,R);let B=a.mul(l,i);w=a.pow(B,W);let T=a.eql(w,a.ONE);i=a.mul(l,ct),w=a.mul(B,p),l=a.cmov(i,l,T),B=a.cmov(w,B,T);for(let _=M;_>c;_--){let x=_-g;x=g<<x-c;let S=a.pow(B,x);const Y=a.eql(S,a.ONE);i=a.mul(l,p),p=a.mul(p,p),S=a.mul(B,p),l=a.cmov(i,l,Y),B=a.cmov(S,B,Y)}return{isValid:T,value:l}};if(a.ORDER%L===E){const R=(a.ORDER-E)/L,y=a.sqrt(a.neg(d));nt=(p,i)=>{let l=a.sqr(i);const w=a.mul(p,i);l=a.mul(l,w);let B=a.pow(l,R);B=a.mul(B,w);const T=a.mul(B,y),_=a.mul(a.sqr(B),i),x=a.eql(_,p);let S=a.cmov(T,B,x);return{isValid:x,value:S}}}return nt}function F(a,d){if(o.validateField(a),!a.isValid(d.A)||!a.isValid(d.B)||!a.isValid(d.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=A(a,d.Z);if(!a.isOdd)throw new Error("Fp.isOdd is not implemented!");return U=>{let M,j,G,k,tt,P,W,q;M=a.sqr(U),M=a.mul(M,d.Z),j=a.sqr(M),j=a.add(j,M),G=a.add(j,a.ONE),G=a.mul(G,d.B),k=a.cmov(d.Z,a.neg(j),!a.eql(j,a.ZERO)),k=a.mul(k,d.A),j=a.sqr(G),P=a.sqr(k),tt=a.mul(P,d.A),j=a.add(j,tt),j=a.mul(j,G),P=a.mul(P,k),tt=a.mul(P,d.B),j=a.add(j,tt),W=a.mul(M,G);const{isValid:ct,value:nt}=e(j,P);q=a.mul(M,U),q=a.mul(q,nt),W=a.cmov(W,G,ct),q=a.cmov(q,nt,ct);const R=a.isOdd(U)===a.isOdd(q);return q=a.cmov(a.neg(q),q,R),W=a.div(W,k),{x:W,y:q}}}})(Ut);Object.defineProperty(St,"__esModule",{value:!0});St.getHash=fe;St.createCurve=Qe;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const We=ye,Xt=Qt,Xe=Ut;function fe(t){return{hash:t,hmac:(r,...o)=>(0,We.hmac)(t,r,(0,Xt.concatBytes)(...o)),randomBytes:Xt.randomBytes}}function Qe(t,r){const o=n=>(0,Xe.weierstrass)({...t,...fe(n)});return Object.freeze({...o(r),create:o})}var Et={};Object.defineProperty(Et,"__esModule",{value:!0});Et.expand_message_xmd=ue;Et.expand_message_xof=le;Et.hash_to_field=$t;Et.isogenyMap=en;Et.createHasher=nn;const Je=K,it=V,Fe=it.bytesToNumberBE;function bt(t,r){if(t<0||t>=1<<8*r)throw new Error("bad I2OSP call: value=".concat(t," length=").concat(r));const o=Array.from({length:r}).fill(0);for(let n=r-1;n>=0;n--)o[n]=t&255,t>>>=8;return new Uint8Array(o)}function tn(t,r){const o=new Uint8Array(t.length);for(let n=0;n<t.length;n++)o[n]=t[n]^r[n];return o}function Vt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ue(t,r,o,n){(0,it.abytes)(t),(0,it.abytes)(r),Vt(o),r.length>255&&(r=n((0,it.concatBytes)((0,it.utf8ToBytes)("H2C-OVERSIZE-DST-"),r)));const{outputLen:f,blockLen:u}=n,m=Math.ceil(o/f);if(m>255)throw new Error("Invalid xmd length");const h=(0,it.concatBytes)(r,bt(r.length,1)),s=bt(0,u),c=bt(o,2),g=new Array(m),E=n((0,it.concatBytes)(s,t,c,bt(0,1),h));g[0]=n((0,it.concatBytes)(E,bt(1,1),h));for(let I=1;I<=m;I++){const N=[tn(E,g[I-1]),bt(I+1,1),h];g[I]=n((0,it.concatBytes)(...N))}return(0,it.concatBytes)(...g).slice(0,o)}function le(t,r,o,n,f){if((0,it.abytes)(t),(0,it.abytes)(r),Vt(o),r.length>255){const u=Math.ceil(2*n/8);r=f.create({dkLen:u}).update((0,it.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(r).digest()}if(o>65535||r.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return f.create({dkLen:o}).update(t).update(bt(o,2)).update(r).update(bt(r.length,1)).digest()}function $t(t,r,o){(0,it.validateObject)(o,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:n,k:f,m:u,hash:m,expand:h,DST:s}=o;(0,it.abytes)(t),Vt(r);const c=typeof s=="string"?(0,it.utf8ToBytes)(s):s,g=n.toString(2).length,E=Math.ceil((g+f)/8),L=r*u*E;let I;if(h==="xmd")I=ue(t,c,L,m);else if(h==="xof")I=le(t,c,L,f,m);else if(h==="_internal_pass")I=t;else throw new Error('expand must be "xmd" or "xof"');const N=new Array(r);for(let H=0;H<r;H++){const A=new Array(u);for(let F=0;F<u;F++){const a=E*(F+H*u),d=I.subarray(a,a+E);A[F]=(0,Je.mod)(Fe(d),n)}N[H]=A}return N}function en(t,r){const o=r.map(n=>Array.from(n).reverse());return(n,f)=>{const[u,m,h,s]=o.map(c=>c.reduce((g,E)=>t.add(t.mul(g,n),E)));return n=t.div(u,m),f=t.mul(f,t.div(h,s)),{x:n,y:f}}}function nn(t,r,o){if(typeof r!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(n,f){const u=$t(n,2,{...o,DST:o.DST,...f}),m=t.fromAffine(r(u[0])),h=t.fromAffine(r(u[1])),s=m.add(h).clearCofactor();return s.assertValidity(),s},encodeToCurve(n,f){const u=$t(n,1,{...o,DST:o.encodeDST,...f}),m=t.fromAffine(r(u[0])).clearCofactor();return m.assertValidity(),m},mapToCurve(n){if(!Array.isArray(n))throw new Error("mapToCurve: expected array of bigints");for(const u of n)if(typeof u!="bigint")throw new Error("mapToCurve: expected array of bigints, got ".concat(u," in array"));const f=t.fromAffine(r(n)).clearCofactor();return f.assertValidity(),f}}}(function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.encodeToCurve=t.hashToCurve=t.schnorr=t.secp256k1=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const r=he,o=Qt,n=St,f=Et,u=K,m=V,h=Ut,s=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),c=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),g=BigInt(1),E=BigInt(2),L=(i,l)=>(i+l/E)/l;function I(i){const l=s,w=BigInt(3),B=BigInt(6),T=BigInt(11),_=BigInt(22),x=BigInt(23),S=BigInt(44),Y=BigInt(88),C=i*i*i%l,O=C*C*i%l,X=(0,u.pow2)(O,w,l)*O%l,Q=(0,u.pow2)(X,w,l)*O%l,rt=(0,u.pow2)(Q,E,l)*C%l,b=(0,u.pow2)(rt,T,l)*rt%l,v=(0,u.pow2)(b,_,l)*b%l,$=(0,u.pow2)(v,S,l)*v%l,D=(0,u.pow2)($,Y,l)*$%l,Z=(0,u.pow2)(D,S,l)*v%l,J=(0,u.pow2)(Z,w,l)*O%l,ot=(0,u.pow2)(J,x,l)*b%l,st=(0,u.pow2)(ot,B,l)*C%l,ut=(0,u.pow2)(st,E,l);if(!N.eql(N.sqr(ut),i))throw new Error("Cannot find square root");return ut}const N=(0,u.Field)(s,void 0,void 0,{sqrt:I});t.secp256k1=(0,n.createCurve)({a:BigInt(0),b:BigInt(7),Fp:N,n:c,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:i=>{const l=c,w=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),B=-g*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),T=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),_=w,x=BigInt("0x100000000000000000000000000000000"),S=L(_*i,l),Y=L(-B*i,l);let C=(0,u.mod)(i-S*w-Y*T,l),O=(0,u.mod)(-S*B-Y*_,l);const X=C>x,Q=O>x;if(X&&(C=l-C),Q&&(O=l-O),C>x||O>x)throw new Error("splitScalar: Endomorphism failed, k="+i);return{k1neg:X,k1:C,k2neg:Q,k2:O}}}},r.sha256);const H=BigInt(0),A=i=>typeof i=="bigint"&&H<i&&i<s,F=i=>typeof i=="bigint"&&H<i&&i<c,a={};function d(i,...l){let w=a[i];if(w===void 0){const B=(0,r.sha256)(Uint8Array.from(i,T=>T.charCodeAt(0)));w=(0,m.concatBytes)(B,B),a[i]=w}return(0,r.sha256)((0,m.concatBytes)(w,...l))}const e=i=>i.toRawBytes(!0).slice(1),U=i=>(0,m.numberToBytesBE)(i,32),M=i=>(0,u.mod)(i,s),j=i=>(0,u.mod)(i,c),G=t.secp256k1.ProjectivePoint,k=(i,l,w)=>G.BASE.multiplyAndAddUnsafe(i,l,w);function tt(i){let l=t.secp256k1.utils.normPrivateKeyToScalar(i),w=G.fromPrivateKey(l);return{scalar:w.hasEvenY()?l:j(-l),bytes:e(w)}}function P(i){if(!A(i))throw new Error("bad x: need 0 < x < p");const l=M(i*i),w=M(l*i+BigInt(7));let B=I(w);B%E!==H&&(B=M(-B));const T=new G(i,B,g);return T.assertValidity(),T}function W(...i){return j((0,m.bytesToNumberBE)(d("BIP0340/challenge",...i)))}function q(i){return tt(i).bytes}function ct(i,l,w=(0,o.randomBytes)(32)){const B=(0,m.ensureBytes)("message",i),{bytes:T,scalar:_}=tt(l),x=(0,m.ensureBytes)("auxRand",w,32),S=U(_^(0,m.bytesToNumberBE)(d("BIP0340/aux",x))),Y=d("BIP0340/nonce",S,T,B),C=j((0,m.bytesToNumberBE)(Y));if(C===H)throw new Error("sign failed: k is zero");const{bytes:O,scalar:X}=tt(C),Q=W(O,T,B),rt=new Uint8Array(64);if(rt.set(O,0),rt.set(U(j(X+Q*_)),32),!nt(rt,B,T))throw new Error("sign: Invalid signature produced");return rt}function nt(i,l,w){const B=(0,m.ensureBytes)("signature",i,64),T=(0,m.ensureBytes)("message",l),_=(0,m.ensureBytes)("publicKey",w,32);try{const x=P((0,m.bytesToNumberBE)(_)),S=(0,m.bytesToNumberBE)(B.subarray(0,32));if(!A(S))return!1;const Y=(0,m.bytesToNumberBE)(B.subarray(32,64));if(!F(Y))return!1;const C=W(U(S),e(x),T),O=k(x,Y,j(-C));return!(!O||!O.hasEvenY()||O.toAffine().x!==S)}catch(x){return!1}}t.schnorr={getPublicKey:q,sign:ct,verify:nt,utils:{randomPrivateKey:t.secp256k1.utils.randomPrivateKey,lift_x:P,pointToBytes:e,numberToBytesBE:m.numberToBytesBE,bytesToNumberBE:m.bytesToNumberBE,taggedHash:d,mod:u.mod}};const R=(0,f.isogenyMap)(N,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(i=>i.map(l=>BigInt(l)))),y=(0,h.mapToCurveSimpleSWU)(N,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:N.create(BigInt("-11"))}),p=(0,f.createHasher)(t.secp256k1.ProjectivePoint,i=>{const{x:l,y:w}=y(N.create(i[0]));return R(l,w)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:N.ORDER,m:1,k:128,expand:"xmd",hash:r.sha256});t.hashToCurve=p.hashToCurve,t.encodeToCurve=p.encodeToCurve})(be);export{cn as E,Tt as c,Et as h,K as m,be as s,V as u};
