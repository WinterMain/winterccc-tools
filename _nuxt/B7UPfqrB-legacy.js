System.register(["./DSdbEaNu-legacy.js","./Cr7M91XK-legacy.js","./CDFmN71C-legacy.js"],(function(e,t){"use strict";var n,r,o,i;return{setters:[e=>{n=e.a3,r=e.bG},e=>{o=e.s},e=>{i=e.h}],execute:function(){var t={exports:{}};!function(e){var t=Object.prototype.hasOwnProperty,n="~";function r(){}function o(e,t,n){this.fn=e,this.context=t,this.once=n||!1}function i(e,t,r,i,s){if("function"!=typeof r)throw new TypeError("The listener must be a function");var a=new o(r,i||e,s),f=n?n+t:t;return e._events[f]?e._events[f].fn?e._events[f]=[e._events[f],a]:e._events[f].push(a):(e._events[f]=a,e._eventsCount++),e}function s(e,t){0==--e._eventsCount?e._events=new r:delete e._events[t]}function a(){this._events=new r,this._eventsCount=0}Object.create&&(r.prototype=Object.create(null),(new r).__proto__||(n=!1)),a.prototype.eventNames=function(){var e,r,o=[];if(0===this._eventsCount)return o;for(r in e=this._events)t.call(e,r)&&o.push(n?r.slice(1):r);return Object.getOwnPropertySymbols?o.concat(Object.getOwnPropertySymbols(e)):o},a.prototype.listeners=function(e){var t=n?n+e:e,r=this._events[t];if(!r)return[];if(r.fn)return[r.fn];for(var o=0,i=r.length,s=new Array(i);o<i;o++)s[o]=r[o].fn;return s},a.prototype.listenerCount=function(e){var t=n?n+e:e,r=this._events[t];return r?r.fn?1:r.length:0},a.prototype.emit=function(e,t,r,o,i,s){var a=n?n+e:e;if(!this._events[a])return!1;var f,c,u=this._events[a],l=arguments.length;if(u.fn){switch(u.once&&this.removeListener(e,u.fn,void 0,!0),l){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,t),!0;case 3:return u.fn.call(u.context,t,r),!0;case 4:return u.fn.call(u.context,t,r,o),!0;case 5:return u.fn.call(u.context,t,r,o,i),!0;case 6:return u.fn.call(u.context,t,r,o,i,s),!0}for(c=1,f=new Array(l-1);c<l;c++)f[c-1]=arguments[c];u.fn.apply(u.context,f)}else{var d,h=u.length;for(c=0;c<h;c++)switch(u[c].once&&this.removeListener(e,u[c].fn,void 0,!0),l){case 1:u[c].fn.call(u[c].context);break;case 2:u[c].fn.call(u[c].context,t);break;case 3:u[c].fn.call(u[c].context,t,r);break;case 4:u[c].fn.call(u[c].context,t,r,o);break;default:if(!f)for(d=1,f=new Array(l-1);d<l;d++)f[d-1]=arguments[d];u[c].fn.apply(u[c].context,f)}}return!0},a.prototype.on=function(e,t,n){return i(this,e,t,n,!1)},a.prototype.once=function(e,t,n){return i(this,e,t,n,!0)},a.prototype.removeListener=function(e,t,r,o){var i=n?n+e:e;if(!this._events[i])return this;if(!t)return s(this,i),this;var a=this._events[i];if(a.fn)a.fn!==t||o&&!a.once||r&&a.context!==r||s(this,i);else{for(var f=0,c=[],u=a.length;f<u;f++)(a[f].fn!==t||o&&!a[f].once||r&&a[f].context!==r)&&c.push(a[f]);c.length?this._events[i]=1===c.length?c[0]:c:s(this,i)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=n?n+e:e,this._events[t]&&s(this,t)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=n,a.EventEmitter=a,e.exports=a}(t),e("E",n(t.exports));var s=e("s",{}),a={},f={},c=e("c",{}),u=e("m",{}),l=e("u",{});Object.defineProperty(l,"__esModule",{value:!0}),l.bitMask=void 0,l.isBytes=p,l.abytes=m,l.bytesToHex=w,l.numberToHexUnpadded=b,l.hexToNumber=E,l.hexToBytes=x,l.bytesToNumberBE=function(e){return E(w(e))},l.bytesToNumberLE=function(e){return m(e),E(w(Uint8Array.from(e).reverse()))},l.numberToBytesBE=S,l.numberToBytesLE=function(e,t){return S(e,t).reverse()},l.numberToVarBytesBE=function(e){return x(b(e))},l.ensureBytes=function(e,t,n){let r;if("string"==typeof t)try{r=x(t)}catch(i){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${i}`)}else{if(!p(t))throw new Error(`${e} must be hex string or Uint8Array`);r=Uint8Array.from(t)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(`${e} expected ${n} bytes, got ${o}`);return r},l.concatBytes=O,l.equalBytes=function(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return 0===n},l.utf8ToBytes=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))},l.bitLen=function(e){let t;for(t=0;e>d;e>>=h,t+=1);return t},l.bitGet=function(e,t){return e>>BigInt(t)&h},l.bitSet=function(e,t,n){return e|(n?h:d)<<BigInt(t)},l.createHmacDrbg=function(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=T(e),o=T(e),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},a=(...e)=>n(o,r,...e),f=(e=T())=>{o=a(A([0]),e),r=a(),0!==e.length&&(o=a(A([1]),e),r=a())},c=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){r=a();const t=r.slice();n.push(t),e+=r.length}return O(...n)};return(e,t)=>{let n;for(s(),f(e);!(n=t(c()));)f();return s(),n}},l.validateObject=function(e,t,n={}){const r=(t,n,r)=>{const o=I[n];if("function"!=typeof o)throw new Error(`Invalid validator "${n}", expected function`);const i=e[t];if(!(r&&void 0===i||o(i,e)))throw new Error(`Invalid param ${String(t)}=${i} (${typeof i}), expected ${n}`)};for(const[o,i]of Object.entries(t))r(o,i,!1);for(const[o,i]of Object.entries(n))r(o,i,!0);return e};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const d=BigInt(0),h=BigInt(1),y=BigInt(2);function p(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function m(e){if(!p(e))throw new Error("Uint8Array expected")}const g=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function w(e){m(e);let t="";for(let n=0;n<e.length;n++)t+=g[e[n]];return t}function b(e){const t=e.toString(16);return 1&t.length?`0${t}`:t}function E(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const B={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function v(e){return e>=B._0&&e<=B._9?e-B._0:e>=B._A&&e<=B._F?e-(B._A-10):e>=B._a&&e<=B._f?e-(B._a-10):void 0}function x(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,n=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let o=0,i=0;o<n;o++,i+=2){const t=v(e.charCodeAt(i)),n=v(e.charCodeAt(i+1));if(void 0===t||void 0===n){const t=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+i)}r[o]=16*t+n}return r}function S(e,t){return x(e.toString(16).padStart(2*t,"0"))}function O(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];m(n),t+=n.length}const n=new Uint8Array(t);for(let r=0,o=0;r<e.length;r++){const t=e[r];n.set(t,o),o+=t.length}return n}l.bitMask=e=>(y<<BigInt(e-1))-h;const T=e=>new Uint8Array(e),A=e=>Uint8Array.from(e),I={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||p(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};Object.defineProperty(u,"__esModule",{value:!0}),u.isNegativeLE=void 0,u.mod=k,u.pow=D,u.pow2=function(e,t,n){let r=e;for(;t-- >R;)r*=r,r%=n;return r},u.invert=U,u.tonelliShanks=j,u.FpSqrt=$,u.validateField=function(e){const t=H.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,_.validateObject)(e,t)},u.FpPow=Z,u.FpInvertBatch=V,u.FpDiv=function(e,t,n){return e.mul(t,"bigint"==typeof n?U(n,e.ORDER):e.inv(n))},u.FpIsSquare=function(e){const t=(e.ORDER-N)/q;return n=>{const r=e.pow(n,t);return e.eql(r,e.ZERO)||e.eql(r,e.ONE)}},u.nLength=z,u.Field=function(e,t,n=!1,r={}){if(e<=R)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:o,nByteLength:i}=z(e,t);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=$(e),a=Object.freeze({ORDER:e,BITS:o,BYTES:i,MASK:(0,_.bitMask)(o),ZERO:R,ONE:N,create:t=>k(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return R<=t&&t<e},is0:e=>e===R,isOdd:e=>(e&N)===N,neg:t=>k(-t,e),eql:(e,t)=>e===t,sqr:t=>k(t*t,e),add:(t,n)=>k(t+n,e),sub:(t,n)=>k(t-n,e),mul:(t,n)=>k(t*n,e),pow:(e,t)=>Z(a,e,t),div:(t,n)=>k(t*U(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>U(t,e),sqrt:r.sqrt||(e=>s(a,e)),invertBatch:e=>V(a,e),cmov:(e,t,n)=>n?t:e,toBytes:e=>n?(0,_.numberToBytesLE)(e,i):(0,_.numberToBytesBE)(e,i),fromBytes:e=>{if(e.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${e.length}`);return n?(0,_.bytesToNumberLE)(e):(0,_.bytesToNumberBE)(e)}});return Object.freeze(a)},u.FpSqrtOdd=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(t);return e.isOdd(n)?n:e.neg(n)},u.FpSqrtEven=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(t);return e.isOdd(n)?e.neg(n):n},u.hashToPrivateScalar=function(e,t,n=!1){const r=(e=(0,_.ensureBytes)("privateHash",e)).length,o=z(t).nByteLength+8;if(o<24||r<o||r>1024)throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${r}`);return k(n?(0,_.bytesToNumberLE)(e):(0,_.bytesToNumberBE)(e),t-N)+N},u.getFieldBytesLength=M,u.getMinHashLength=K,u.mapHashToField=function(e,t,n=!1){const r=e.length,o=M(t),i=K(t);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const s=k(n?(0,_.bytesToNumberBE)(e):(0,_.bytesToNumberLE)(e),t-N)+N;return n?(0,_.numberToBytesLE)(s,o):(0,_.numberToBytesBE)(s,o)};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _=l,R=BigInt(0),N=BigInt(1),q=BigInt(2),P=BigInt(3),C=BigInt(4),F=BigInt(5),L=BigInt(8);function k(e,t){const n=e%t;return n>=R?n:t+n}function D(e,t,n){if(n<=R||t<R)throw new Error("Expected power/modulo > 0");if(n===N)return R;let r=N;for(;t>R;)t&N&&(r=r*e%n),e=e*e%n,t>>=N;return r}function U(e,t){if(e===R||t<=R)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=k(e,t),r=t,o=R,i=N;for(;n!==R;){const e=r%n,t=o-i*(r/n);r=n,n=e,o=i,i=t}if(r!==N)throw new Error("invert: does not exist");return k(o,t)}function j(e){const t=(e-N)/q;let n,r,o;for(n=e-N,r=0;n%q===R;n/=q,r++);for(o=q;o<e&&D(o,t,e)!==e-N;o++);if(1===r){const t=(e+N)/C;return function(e,n){const r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}}const i=(n+N)/q;return function(e,s){if(e.pow(s,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=r,f=e.pow(e.mul(e.ONE,o),n),c=e.pow(s,i),u=e.pow(s,n);for(;!e.eql(u,e.ONE);){if(e.eql(u,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(u);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const n=e.pow(f,N<<BigInt(a-t-1));f=e.sqr(n),c=e.mul(c,n),u=e.mul(u,f),a=t}return c}}function $(e){if(e%C===P){const t=(e+N)/C;return function(e,n){const r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}}if(e%L===F){const t=(e-F)/L;return function(e,n){const r=e.mul(n,q),o=e.pow(r,t),i=e.mul(n,o),s=e.mul(e.mul(i,q),o),a=e.mul(i,e.sub(s,e.ONE));if(!e.eql(e.sqr(a),n))throw new Error("Cannot find square root");return a}}return j(e)}BigInt(9),BigInt(16),u.isNegativeLE=(e,t)=>(k(e,t)&N)===N;const H=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Z(e,t,n){if(n<R)throw new Error("Expected power > 0");if(n===R)return e.ONE;if(n===N)return t;let r=e.ONE,o=t;for(;n>R;)n&N&&(r=e.mul(r,o)),o=e.sqr(o),n>>=N;return r}function V(e,t){const n=new Array(t.length),r=t.reduce(((t,r,o)=>e.is0(r)?t:(n[o]=t,e.mul(t,r))),e.ONE),o=e.inv(r);return t.reduceRight(((t,r,o)=>e.is0(r)?t:(n[o]=e.mul(t,n[o]),e.mul(t,r))),o),n}function z(e,t){const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function M(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function K(e){const t=M(e);return t+Math.ceil(t/2)}Object.defineProperty(c,"__esModule",{value:!0}),c.wNAF=function(e,t){const n=(e,t)=>{const n=t.negate();return e?n:t},r=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:n,unsafeLadder(t,n){let r=e.ZERO,o=t;for(;n>G;)n&X&&(r=r.add(o)),o=o.double(),n>>=X;return r},precomputeWindow(e,t){const{windows:n,windowSize:o}=r(t),i=[];let s=e,a=s;for(let r=0;r<n;r++){a=s,i.push(a);for(let e=1;e<o;e++)a=a.add(s),i.push(a);s=a.double()}return i},wNAF(t,o,i){const{windows:s,windowSize:a}=r(t);let f=e.ZERO,c=e.BASE;const u=BigInt(2**t-1),l=2**t,d=BigInt(t);for(let e=0;e<s;e++){const t=e*a;let r=Number(i&u);i>>=d,r>a&&(r-=l,i+=X);const s=t,h=t+Math.abs(r)-1,y=e%2!=0,p=r<0;0===r?c=c.add(n(y,o[s])):f=f.add(n(p,o[h]))}return{p:f,f:c}},wNAFCached(e,t,n,r){const o=e._WINDOW_SIZE||1;let i=t.get(e);return i||(i=this.precomputeWindow(e,o),1!==o&&t.set(e,r(i))),this.wNAF(o,i,n)}}},c.validateBasic=function(e){return(0,W.validateField)(e.Fp),(0,Y.validateObject)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,W.nLength)(e.n,e.nBitLength),...e,p:e.Fp.ORDER})};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const W=u,Y=l,G=BigInt(0),X=BigInt(1);!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.DER=void 0,e.weierstrassPoints=p,e.weierstrass=function(i){const s=function(e){const n=(0,t.validateBasic)(e);return r.validateObject(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}(i),{Fp:c,n:u}=s,l=c.BYTES+1,d=2*c.BYTES+1;function h(e){return n.mod(e,u)}function y(e){return n.invert(e,u)}const{ProjectivePoint:m,normPrivateKeyToScalar:g,weierstrassEquation:w,isWithinCurveOrder:b}=p({...s,toBytes(e,t,n){const o=t.toAffine(),i=c.toBytes(o.x),s=r.concatBytes;return n?s(Uint8Array.from([t.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,c.toBytes(o.y))},fromBytes(e){const t=e.length,n=e[0],o=e.subarray(1);if(t!==l||2!==n&&3!==n){if(t===d&&4===n)return{x:c.fromBytes(o.subarray(0,c.BYTES)),y:c.fromBytes(o.subarray(c.BYTES,2*c.BYTES))};throw new Error(`Point of length ${t} was invalid. Expected ${l} compressed bytes or ${d} uncompressed bytes`)}{const e=r.bytesToNumberBE(o);if(!(a<(i=e)&&i<c.ORDER))throw new Error("Point is not on curve");const t=w(e);let u;try{u=c.sqrt(t)}catch(s){const e=s instanceof Error?": "+s.message:"";throw new Error("Point is not on curve"+e)}return!(1&~n)!=((u&f)===f)&&(u=c.neg(u)),{x:e,y:u}}var i}}),E=e=>r.bytesToHex(r.numberToBytesBE(e,s.nByteLength));function B(e){return e>u>>f}const v=(e,t,n)=>r.bytesToNumberBE(e.slice(t,n));class x{constructor(e,t,n){this.r=e,this.s=t,this.recovery=n,this.assertValidity()}static fromCompact(e){const t=s.nByteLength;return e=(0,o.ensureBytes)("compactSignature",e,2*t),new x(v(e,0,t),v(e,t,2*t))}static fromDER(t){const{r:n,s:r}=e.DER.toSig((0,o.ensureBytes)("DER",t));return new x(n,r)}assertValidity(){if(!b(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!b(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new x(this.r,this.s,e)}recoverPublicKey(e){const{r:t,s:n,recovery:r}=this,i=A((0,o.ensureBytes)("msgHash",e));if(null==r||![0,1,2,3].includes(r))throw new Error("recovery id invalid");const a=2===r||3===r?t+s.n:t;if(a>=c.ORDER)throw new Error("recovery id 2 or 3 invalid");const f=1&r?"03":"02",u=m.fromHex(f+E(a)),l=y(a),d=h(-i*l),p=h(n*l),g=m.BASE.multiplyAndAddUnsafe(u,d,p);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,h(-this.s),this.recovery):this}toDERRawBytes(){return r.hexToBytes(this.toDERHex())}toDERHex(){return e.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return r.hexToBytes(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const S={isValidPrivateKey(e){try{return g(e),!0}catch(t){return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const e=n.getMinHashLength(s.n);return n.mapHashToField(s.randomBytes(e),s.n)},precompute:(e=8,t=m.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function O(e){const t=r.isBytes(e),n="string"==typeof e,o=(t||n)&&e.length;return t?o===l||o===d:n?o===2*l||o===2*d:e instanceof m}const T=s.bits2int||function(e){const t=r.bytesToNumberBE(e),n=8*e.length-s.nBitLength;return n>0?t>>BigInt(n):t},A=s.bits2int_modN||function(e){return h(T(e))},I=r.bitMask(s.nBitLength);function _(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(a<=e&&e<I))throw new Error(`bigint expected < 2^${s.nBitLength}`);return r.numberToBytesBE(e,s.nByteLength)}function R(e,t,n=N){if(["recovered","canonical"].some((e=>e in n)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=s;let{lowS:l,prehash:d,extraEntropy:p}=n;null==l&&(l=!0),e=(0,o.ensureBytes)("msgHash",e),d&&(e=(0,o.ensureBytes)("prehashed msgHash",i(e)));const w=A(e),E=g(t),v=[_(E),_(w)];if(null!=p&&!1!==p){const e=!0===p?u(c.BYTES):p;v.push((0,o.ensureBytes)("extraEntropy",e))}const S=r.concatBytes(...v),O=w;return{seed:S,k2sig:function(e){const t=T(e);if(!b(t))return;const n=y(t),r=m.BASE.multiply(t).toAffine(),o=h(r.x);if(o===a)return;const i=h(n*h(O+o*E));if(i===a)return;let s=(r.x===o?0:2)|Number(r.y&f),c=i;return l&&B(i)&&(c=function(e){return B(e)?h(-e):e}(i),s^=1),new x(o,c,s)}}}const N={lowS:s.lowS,prehash:!1},q={lowS:s.lowS,prehash:!1};return m.BASE._setWindowSize(8),{CURVE:s,getPublicKey:function(e,t=!0){return m.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,n=!0){if(O(e))throw new Error("first arg must be private key");if(!O(t))throw new Error("second arg must be public key");return m.fromHex(t).multiply(g(e)).toRawBytes(n)},sign:function(e,t,n=N){const{seed:o,k2sig:i}=R(e,t,n),a=s;return r.createHmacDrbg(a.hash.outputLen,a.nByteLength,a.hmac)(o,i)},verify:function(t,n,i,a=q){const f=t;if(n=(0,o.ensureBytes)("msgHash",n),i=(0,o.ensureBytes)("publicKey",i),"strict"in a)throw new Error("options.strict was renamed to lowS");const{lowS:c,prehash:u}=a;let l,d;try{if("string"==typeof f||r.isBytes(f))try{l=x.fromDER(f)}catch(S){if(!(S instanceof e.DER.Err))throw S;l=x.fromCompact(f)}else{if("object"!=typeof f||"bigint"!=typeof f.r||"bigint"!=typeof f.s)throw new Error("PARSE");{const{r:e,s:t}=f;l=new x(e,t)}}d=m.fromHex(i)}catch(O){if("PARSE"===O.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&l.hasHighS())return!1;u&&(n=s.hash(n));const{r:p,s:g}=l,w=A(n),b=y(g),E=h(w*b),B=h(p*b),v=m.BASE.multiplyAndAddUnsafe(d,E,B)?.toAffine();return!!v&&h(v.x)===p},ProjectivePoint:m,Signature:x,utils:S}},e.SWUFpSqrtRatio=m,e.mapToCurveSimpleSWU=function(e,t){if(n.validateField(e),!e.isValid(t.A)||!e.isValid(t.B)||!e.isValid(t.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=m(e,t.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return n=>{let o,i,s,a,f,c,u,l;o=e.sqr(n),o=e.mul(o,t.Z),i=e.sqr(o),i=e.add(i,o),s=e.add(i,e.ONE),s=e.mul(s,t.B),a=e.cmov(t.Z,e.neg(i),!e.eql(i,e.ZERO)),a=e.mul(a,t.A),i=e.sqr(s),c=e.sqr(a),f=e.mul(c,t.A),i=e.add(i,f),i=e.mul(i,s),c=e.mul(c,a),f=e.mul(c,t.B),i=e.add(i,f),u=e.mul(o,s);const{isValid:d,value:h}=r(i,c);l=e.mul(o,n),l=e.mul(l,h),u=e.cmov(u,s,d),l=e.cmov(l,h,d);const y=e.isOdd(n)===e.isOdd(l);return l=e.cmov(e.neg(l),l,y),u=e.div(u,a),{x:u,y:l}}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const t=c,n=u,r=l,o=l,{bytesToNumberBE:i,hexToBytes:s}=r;e.DER={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:n}=e.DER;if(t.length<2||2!==t[0])throw new n("Invalid signature integer tag");const r=t[1],o=t.subarray(2,r+2);if(!r||o.length!==r)throw new n("Invalid signature integer: wrong length");if(128&o[0])throw new n("Invalid signature integer: negative");if(0===o[0]&&!(128&o[1]))throw new n("Invalid signature integer: unnecessary leading zero");return{d:i(o),l:t.subarray(r+2)}},toSig(t){const{Err:n}=e.DER,o="string"==typeof t?s(t):t;r.abytes(o);let i=o.length;if(i<2||48!=o[0])throw new n("Invalid signature tag");if(o[1]!==i-2)throw new n("Invalid signature: incorrect length");const{d:a,l:f}=e.DER._parseInt(o.subarray(2)),{d:c,l:u}=e.DER._parseInt(f);if(u.length)throw new n("Invalid signature: left bytes after parsing");return{r:a,s:c}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,n=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},r=t(n(e.s)),o=t(n(e.r)),i=r.length/2,s=o.length/2,a=n(i),f=n(s);return`30${n(s+i+4)}02${f}${o}02${a}${r}`}};const a=BigInt(0),f=BigInt(1),d=BigInt(2),h=BigInt(3),y=BigInt(4);function p(e){const i=function(e){const n=(0,t.validateBasic)(e);r.validateObject(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:o,Fp:i,a:s}=n;if(o){if(!i.eql(s,i.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof o||"bigint"!=typeof o.beta||"function"!=typeof o.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}(e),{Fp:s}=i,c=i.toBytes||((e,t,n)=>{const o=t.toAffine();return r.concatBytes(Uint8Array.from([4]),s.toBytes(o.x),s.toBytes(o.y))}),u=i.fromBytes||(e=>{const t=e.subarray(1);return{x:s.fromBytes(t.subarray(0,s.BYTES)),y:s.fromBytes(t.subarray(s.BYTES,2*s.BYTES))}});function l(e){const{a:t,b:n}=i,r=s.sqr(e),o=s.mul(r,e);return s.add(s.add(o,s.mul(e,t)),n)}if(!s.eql(s.sqr(i.Gy),l(i.Gx)))throw new Error("bad generator point: equation left != right");function d(e){return"bigint"==typeof e&&a<e&&e<i.n}function y(e){if(!d(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function p(e){const{allowedPrivateKeyLengths:t,nByteLength:s,wrapPrivateKey:a,n:f}=i;if(t&&"bigint"!=typeof e){if(r.isBytes(e)&&(e=r.bytesToHex(e)),"string"!=typeof e||!t.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*s,"0")}let c;try{c="bigint"==typeof e?e:r.bytesToNumberBE((0,o.ensureBytes)("private key",e,s))}catch(u){throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof e}`)}return a&&(c=n.mod(c,f)),y(c),c}const m=new Map;function g(e){if(!(e instanceof w))throw new Error("ProjectivePoint expected")}class w{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!s.isValid(e))throw new Error("x required");if(null==t||!s.isValid(t))throw new Error("y required");if(null==n||!s.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!s.isValid(t)||!s.isValid(n))throw new Error("invalid affine point");if(e instanceof w)throw new Error("projective point not allowed");const r=e=>s.eql(e,s.ZERO);return r(t)&&r(n)?w.ZERO:new w(t,n,s.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=s.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(w.fromAffine)}static fromHex(e){const t=w.fromAffine(u((0,o.ensureBytes)("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return w.BASE.multiply(p(e))}_setWindowSize(e){this._WINDOW_SIZE=e,m.delete(this)}assertValidity(){if(this.is0()){if(i.allowInfinityPoint&&!s.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:t}=this.toAffine();if(!s.isValid(e)||!s.isValid(t))throw new Error("bad point: x or y not FE");const n=s.sqr(t),r=l(e);if(!s.eql(n,r))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(s.isOdd)return!s.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){g(e);const{px:t,py:n,pz:r}=this,{px:o,py:i,pz:a}=e,f=s.eql(s.mul(t,a),s.mul(o,r)),c=s.eql(s.mul(n,a),s.mul(i,r));return f&&c}negate(){return new w(this.px,s.neg(this.py),this.pz)}double(){const{a:e,b:t}=i,n=s.mul(t,h),{px:r,py:o,pz:a}=this;let f=s.ZERO,c=s.ZERO,u=s.ZERO,l=s.mul(r,r),d=s.mul(o,o),y=s.mul(a,a),p=s.mul(r,o);return p=s.add(p,p),u=s.mul(r,a),u=s.add(u,u),f=s.mul(e,u),c=s.mul(n,y),c=s.add(f,c),f=s.sub(d,c),c=s.add(d,c),c=s.mul(f,c),f=s.mul(p,f),u=s.mul(n,u),y=s.mul(e,y),p=s.sub(l,y),p=s.mul(e,p),p=s.add(p,u),u=s.add(l,l),l=s.add(u,l),l=s.add(l,y),l=s.mul(l,p),c=s.add(c,l),y=s.mul(o,a),y=s.add(y,y),l=s.mul(y,p),f=s.sub(f,l),u=s.mul(y,d),u=s.add(u,u),u=s.add(u,u),new w(f,c,u)}add(e){g(e);const{px:t,py:n,pz:r}=this,{px:o,py:a,pz:f}=e;let c=s.ZERO,u=s.ZERO,l=s.ZERO;const d=i.a,y=s.mul(i.b,h);let p=s.mul(t,o),m=s.mul(n,a),b=s.mul(r,f),E=s.add(t,n),B=s.add(o,a);E=s.mul(E,B),B=s.add(p,m),E=s.sub(E,B),B=s.add(t,r);let v=s.add(o,f);return B=s.mul(B,v),v=s.add(p,b),B=s.sub(B,v),v=s.add(n,r),c=s.add(a,f),v=s.mul(v,c),c=s.add(m,b),v=s.sub(v,c),l=s.mul(d,B),c=s.mul(y,b),l=s.add(c,l),c=s.sub(m,l),l=s.add(m,l),u=s.mul(c,l),m=s.add(p,p),m=s.add(m,p),b=s.mul(d,b),B=s.mul(y,B),m=s.add(m,b),b=s.sub(p,b),b=s.mul(d,b),B=s.add(B,b),p=s.mul(m,B),u=s.add(u,p),p=s.mul(v,B),c=s.mul(E,c),c=s.sub(c,p),p=s.mul(E,m),l=s.mul(v,l),l=s.add(l,p),new w(c,u,l)}subtract(e){return this.add(e.negate())}is0(){return this.equals(w.ZERO)}wNAF(e){return E.wNAFCached(this,m,e,(e=>{const t=s.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(w.fromAffine)}))}multiplyUnsafe(e){const t=w.ZERO;if(e===a)return t;if(y(e),e===f)return this;const{endo:n}=i;if(!n)return E.unsafeLadder(this,e);let{k1neg:r,k1:o,k2neg:c,k2:u}=n.splitScalar(e),l=t,d=t,h=this;for(;o>a||u>a;)o&f&&(l=l.add(h)),u&f&&(d=d.add(h)),h=h.double(),o>>=f,u>>=f;return r&&(l=l.negate()),c&&(d=d.negate()),d=new w(s.mul(d.px,n.beta),d.py,d.pz),l.add(d)}multiply(e){y(e);let t,n,r=e;const{endo:o}=i;if(o){const{k1neg:e,k1:i,k2neg:a,k2:f}=o.splitScalar(r);let{p:c,f:u}=this.wNAF(i),{p:l,f:d}=this.wNAF(f);c=E.constTimeNegate(e,c),l=E.constTimeNegate(a,l),l=new w(s.mul(l.px,o.beta),l.py,l.pz),t=c.add(l),n=u.add(d)}else{const{p:e,f:o}=this.wNAF(r);t=e,n=o}return w.normalizeZ([t,n])[0]}multiplyAndAddUnsafe(e,t,n){const r=w.BASE,o=(e,t)=>t!==a&&t!==f&&e.equals(r)?e.multiply(t):e.multiplyUnsafe(t),i=o(this,t).add(o(e,n));return i.is0()?void 0:i}toAffine(e){const{px:t,py:n,pz:r}=this,o=this.is0();null==e&&(e=o?s.ONE:s.inv(r));const i=s.mul(t,e),a=s.mul(n,e),f=s.mul(r,e);if(o)return{x:s.ZERO,y:s.ZERO};if(!s.eql(f,s.ONE))throw new Error("invZ was invalid");return{x:i,y:a}}isTorsionFree(){const{h:e,isTorsionFree:t}=i;if(e===f)return!0;if(t)return t(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:t}=i;return e===f?this:t?t(w,this):this.multiplyUnsafe(i.h)}toRawBytes(e=!0){return this.assertValidity(),c(w,this,e)}toHex(e=!0){return r.bytesToHex(this.toRawBytes(e))}}w.BASE=new w(i.Gx,i.Gy,s.ONE),w.ZERO=new w(s.ZERO,s.ONE,s.ZERO);const b=i.nBitLength,E=(0,t.wNAF)(w,i.endo?Math.ceil(b/2):b);return{CURVE:i,ProjectivePoint:w,normPrivateKeyToScalar:p,weierstrassEquation:l,isWithinCurveOrder:d}}function m(e,t){const n=e.ORDER;let r=a;for(let h=n-f;h%d===a;h/=d)r+=f;const o=r,i=d<<o-f-f,s=i*d,c=(n-f)/s,u=(c-f)/d,l=s-f,p=i,m=e.pow(t,c),g=e.pow(t,(c+f)/d);let w=(t,n)=>{let r=m,i=e.pow(n,l),s=e.sqr(i);s=e.mul(s,n);let a=e.mul(t,s);a=e.pow(a,u),a=e.mul(a,i),i=e.mul(a,n),s=e.mul(a,t);let c=e.mul(s,i);a=e.pow(c,p);let h=e.eql(a,e.ONE);i=e.mul(s,g),a=e.mul(c,r),s=e.cmov(i,s,h),c=e.cmov(a,c,h);for(let u=o;u>f;u--){let t=u-d;t=d<<t-f;let n=e.pow(c,t);const o=e.eql(n,e.ONE);i=e.mul(s,r),r=e.mul(r,r),n=e.mul(c,r),s=e.cmov(i,s,o),c=e.cmov(n,c,o)}return{isValid:h,value:s}};if(e.ORDER%y===h){const n=(e.ORDER-h)/y,r=e.sqrt(e.neg(t));w=(t,o)=>{let i=e.sqr(o);const s=e.mul(t,o);i=e.mul(i,s);let a=e.pow(i,n);a=e.mul(a,s);const f=e.mul(a,r),c=e.mul(e.sqr(a),o),u=e.eql(c,t);return{isValid:u,value:e.cmov(f,a,u)}}}return w}}(f),Object.defineProperty(a,"__esModule",{value:!0}),a.getHash=te,a.createCurve=function(e,t){const n=t=>(0,ee.weierstrass)({...e,...te(t)});return Object.freeze({...n(t),create:n})};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const J=i,Q=r,ee=f;function te(e){return{hash:e,hmac:(t,...n)=>(0,J.hmac)(e,t,(0,Q.concatBytes)(...n)),randomBytes:Q.randomBytes}}var ne=e("h",{});Object.defineProperty(ne,"__esModule",{value:!0}),ne.expand_message_xmd=ce,ne.expand_message_xof=ue,ne.hash_to_field=le,ne.isogenyMap=function(e,t){const n=t.map((e=>Array.from(e).reverse()));return(t,r)=>{const[o,i,s,a]=n.map((n=>n.reduce(((n,r)=>e.add(e.mul(n,t),r)))));return t=e.div(o,i),r=e.mul(r,e.div(s,a)),{x:t,y:r}}},ne.createHasher=function(e,t,n){if("function"!=typeof t)throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=le(r,2,{...n,DST:n.DST,...o}),s=e.fromAffine(t(i[0])),a=e.fromAffine(t(i[1])),f=s.add(a).clearCofactor();return f.assertValidity(),f},encodeToCurve(r,o){const i=le(r,1,{...n,DST:n.encodeDST,...o}),s=e.fromAffine(t(i[0])).clearCofactor();return s.assertValidity(),s},mapToCurve(n){if(!Array.isArray(n))throw new Error("mapToCurve: expected array of bigints");for(const e of n)if("bigint"!=typeof e)throw new Error(`mapToCurve: expected array of bigints, got ${e} in array`);const r=e.fromAffine(t(n)).clearCofactor();return r.assertValidity(),r}}};const re=u,oe=l,ie=oe.bytesToNumberBE;function se(e,t){if(e<0||e>=1<<8*t)throw new Error(`bad I2OSP call: value=${e} length=${t}`);const n=Array.from({length:t}).fill(0);for(let r=t-1;r>=0;r--)n[r]=255&e,e>>>=8;return new Uint8Array(n)}function ae(e,t){const n=new Uint8Array(e.length);for(let r=0;r<e.length;r++)n[r]=e[r]^t[r];return n}function fe(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function ce(e,t,n,r){(0,oe.abytes)(e),(0,oe.abytes)(t),fe(n),t.length>255&&(t=r((0,oe.concatBytes)((0,oe.utf8ToBytes)("H2C-OVERSIZE-DST-"),t)));const{outputLen:o,blockLen:i}=r,s=Math.ceil(n/o);if(s>255)throw new Error("Invalid xmd length");const a=(0,oe.concatBytes)(t,se(t.length,1)),f=se(0,i),c=se(n,2),u=new Array(s),l=r((0,oe.concatBytes)(f,e,c,se(0,1),a));u[0]=r((0,oe.concatBytes)(l,se(1,1),a));for(let d=1;d<=s;d++){const e=[ae(l,u[d-1]),se(d+1,1),a];u[d]=r((0,oe.concatBytes)(...e))}return(0,oe.concatBytes)(...u).slice(0,n)}function ue(e,t,n,r,o){if((0,oe.abytes)(e),(0,oe.abytes)(t),fe(n),t.length>255){const e=Math.ceil(2*r/8);t=o.create({dkLen:e}).update((0,oe.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()}if(n>65535||t.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(e).update(se(n,2)).update(t).update(se(t.length,1)).digest()}function le(e,t,n){(0,oe.validateObject)(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:s,expand:a,DST:f}=n;(0,oe.abytes)(e),fe(t);const c="string"==typeof f?(0,oe.utf8ToBytes)(f):f,u=r.toString(2).length,l=Math.ceil((u+o)/8),d=t*i*l;let h;if("xmd"===a)h=ce(e,c,d,s);else if("xof"===a)h=ue(e,c,d,o,s);else{if("_internal_pass"!==a)throw new Error('expand must be "xmd" or "xof"');h=e}const y=new Array(t);for(let p=0;p<t;p++){const e=new Array(i);for(let t=0;t<i;t++){const n=l*(t+p*i),o=h.subarray(n,n+l);e[t]=(0,re.mod)(ie(o),r)}y[p]=e}return y}!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.schnorr=e.secp256k1=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const t=o,n=r,i=a,s=ne,c=u,d=l,h=f,y=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),p=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),m=BigInt(1),g=BigInt(2),w=(e,t)=>(e+t/g)/t;function b(e){const t=y,n=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),f=BigInt(88),u=e*e*e%t,l=u*u*e%t,d=(0,c.pow2)(l,n,t)*l%t,h=(0,c.pow2)(d,n,t)*l%t,p=(0,c.pow2)(h,g,t)*u%t,m=(0,c.pow2)(p,o,t)*p%t,w=(0,c.pow2)(m,i,t)*m%t,b=(0,c.pow2)(w,a,t)*w%t,B=(0,c.pow2)(b,f,t)*b%t,v=(0,c.pow2)(B,a,t)*w%t,x=(0,c.pow2)(v,n,t)*l%t,S=(0,c.pow2)(x,s,t)*m%t,O=(0,c.pow2)(S,r,t)*u%t,T=(0,c.pow2)(O,g,t);if(!E.eql(E.sqr(T),e))throw new Error("Cannot find square root");return T}const E=(0,c.Field)(y,void 0,void 0,{sqrt:b});e.secp256k1=(0,i.createCurve)({a:BigInt(0),b:BigInt(7),Fp:E,n:p,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=p,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-m*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,s=BigInt("0x100000000000000000000000000000000"),a=w(i*e,t),f=w(-r*e,t);let u=(0,c.mod)(e-a*n-f*o,t),l=(0,c.mod)(-a*r-f*i,t);const d=u>s,h=l>s;if(d&&(u=t-u),h&&(l=t-l),u>s||l>s)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:d,k1:u,k2neg:h,k2:l}}}},t.sha256);const B=BigInt(0),v=e=>"bigint"==typeof e&&B<e&&e<y,x=e=>"bigint"==typeof e&&B<e&&e<p,S={};function O(e,...n){let r=S[e];if(void 0===r){const n=(0,t.sha256)(Uint8Array.from(e,(e=>e.charCodeAt(0))));r=(0,d.concatBytes)(n,n),S[e]=r}return(0,t.sha256)((0,d.concatBytes)(r,...n))}const T=e=>e.toRawBytes(!0).slice(1),A=e=>(0,d.numberToBytesBE)(e,32),I=e=>(0,c.mod)(e,y),_=e=>(0,c.mod)(e,p),R=e.secp256k1.ProjectivePoint,N=(e,t,n)=>R.BASE.multiplyAndAddUnsafe(e,t,n);function q(t){let n=e.secp256k1.utils.normPrivateKeyToScalar(t),r=R.fromPrivateKey(n);return{scalar:r.hasEvenY()?n:_(-n),bytes:T(r)}}function P(e){if(!v(e))throw new Error("bad x: need 0 < x < p");const t=I(e*e);let n=b(I(t*e+BigInt(7)));n%g!==B&&(n=I(-n));const r=new R(e,n,m);return r.assertValidity(),r}function C(...e){return _((0,d.bytesToNumberBE)(O("BIP0340/challenge",...e)))}function F(e){return q(e).bytes}function L(e,t,r=(0,n.randomBytes)(32)){const o=(0,d.ensureBytes)("message",e),{bytes:i,scalar:s}=q(t),a=(0,d.ensureBytes)("auxRand",r,32),f=A(s^(0,d.bytesToNumberBE)(O("BIP0340/aux",a))),c=O("BIP0340/nonce",f,i,o),u=_((0,d.bytesToNumberBE)(c));if(u===B)throw new Error("sign failed: k is zero");const{bytes:l,scalar:h}=q(u),y=C(l,i,o),p=new Uint8Array(64);if(p.set(l,0),p.set(A(_(h+y*s)),32),!k(p,o,i))throw new Error("sign: Invalid signature produced");return p}function k(e,t,n){const r=(0,d.ensureBytes)("signature",e,64),o=(0,d.ensureBytes)("message",t),i=(0,d.ensureBytes)("publicKey",n,32);try{const e=P((0,d.bytesToNumberBE)(i)),t=(0,d.bytesToNumberBE)(r.subarray(0,32));if(!v(t))return!1;const n=(0,d.bytesToNumberBE)(r.subarray(32,64));if(!x(n))return!1;const s=C(A(t),T(e),o),a=N(e,n,_(-s));return!(!a||!a.hasEvenY()||a.toAffine().x!==t)}catch(s){return!1}}e.schnorr={getPublicKey:F,sign:L,verify:k,utils:{randomPrivateKey:e.secp256k1.utils.randomPrivateKey,lift_x:P,pointToBytes:T,numberToBytesBE:d.numberToBytesBE,bytesToNumberBE:d.bytesToNumberBE,taggedHash:O,mod:c.mod}};const D=(()=>(0,s.isogenyMap)(E,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e=>e.map((e=>BigInt(e)))))))(),U=(()=>(0,h.mapToCurveSimpleSWU)(E,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:E.create(BigInt("-11"))}))(),j=(()=>(0,s.createHasher)(e.secp256k1.ProjectivePoint,(e=>{const{x:t,y:n}=U(E.create(e[0]));return D(t,n)}),{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:E.ORDER,m:1,k:128,expand:"xmd",hash:t.sha256}))();e.hashToCurve=j.hashToCurve,e.encodeToCurve=j.encodeToCurve}(s)}}}));
